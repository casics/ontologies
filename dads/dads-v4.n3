@prefix : <http://www.atl.lmco.com/dads#> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix org: <http://www.w3.org/2001/04/roadmap/org#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .


<>a owl:Ontology;
	dc:creator "Todd Hughes";
	dc:creator "Paul E. Black";
 	dc:publisher "Lockheed Martin Advanced Technology Laboratories";
	dc:publisher "NIST";
	rdfs:comment "An upper ontology of algorithms and data structures based on the NIST Dictionary of Algorithms and Data Structures.";
	rdfs:label "Upper Ontology of Algorithms and Data Structures";
	owl:versionInfo "version 0.4 16 Mar 2005" .

:MathematicalThing     a owl:Class;
	rdfs:subClassOf owl:Class;
	rdfs:comment "Instances of this classes are Algorithms, Data Structures, Abstract Data Types, or Algorithmic Techniques.".

:Algorithm     a owl:Class;
	rdfs:subClassOf :MathematicalThing;
	rdfs:comment "This class represents computable sets of steps to achieve desired results.";
	rdfs:label "Algorithm".

:DataStructure     a owl:Class;
	rdfs:subClassOf :MathematicalThing;
	rdfs:comment "This class represents organizations of information, usually in memory, for better algorithm efficiency, such as queue, stack, linked list, heap, dictionary, and tree, or conceptual unity, such as the name and address of a person. It may include redundant information, such as length of the list or number of nodes in a subtree.";
	rdfs:label "Data Structure".
     
:AbstractDataType     a owl:Class;
	rdfs:subClassOf :MathematicalThing;
	rdfs:comment "This class represents sets of data values and associated Algorithmic Techniques that are precisely specified independent of any particular implementation. Abstract Data Types can be components of either Algorithms or Data Structures.";
	rdfs:label "Abstract Data Type".

:AlgorithmicTechnique     a owl:Class;
	rdfs:subClassOf :MathematicalThing;
	rdfs:comment "This class represents general computational techniques.  An Algorithmic Technique is NOT an Algorithm; rather, Algorithms use Algorithmic Techniques.";
	rdfs:label "Algorithmic Technique". 

:Definition     a owl:Class;
	rdfs:subClassOf owl:Class;
	rdfs:comment "This class is at present simply a placeholder that occupies the superclass position for Definitions.  Definitions are atomic elements, like vertex, or adjectives, like root or stable (sort).";
	rdfs:label "Definition".

:Program     a owl:Class;
	rdfs:comment "An instance of this class is a program that executes an algorithm.";
	rdfs:label "Program".

:computedBy     a owl:ObjectProperty;
	rdfs:comment "This property relates an instance of Algorithmic Technique with an instance of Algorithm.  It says that the Algorithmic Technique can be performed by the Algorithm.";
	rdfs:label "Computed By";
	rdfs:domain :AlgorithmicTechnique;
	rdfs:range :Algorithm.

:aggregateChild     a owl:ObjectProperty;
	rdfs:comment "The property says that an Algorithm or Data Structure uses another Algorithm or Data Structure in its computation.  For example, an aggregate child of Heap Sort is Heap.";
	rdfs:label "Aggregate Child";
	rdfs:domain :MathematicalThing;
	rdfs:range :MathematicalThing.

:complexity_Worst     a owl:DatatypeProperty;
	rdfs:comment "For now, this property relates an instance of algorithm with a string conveying its complexity in the worst case, e.g., O(n^2).";
	rdfs:label "Worst Case Complexity";
	rdfs:domain :Algorithm;
	rdfs:range <http://www.w3.org/2001/XMLSchema#string> .

:complexity_Average     a owl:DatatypeProperty;
	rdfs:comment "For now, this property relates an instance of algorithm with a string conveying its complexity in the typical case, e.g., O(n log n).";
	rdfs:label "Average Case Complexity";
	rdfs:domain :Algorithm;
	rdfs:range <http://www.w3.org/2001/XMLSchema#string> .

:implements       a owl:ObjectProperty;
	rdfs:comment "This property relates an instances of Program with instances of Algorithm or Data Structure.  It means that the Program is executable code for the Algorithm or Data Structure."; 
	rdfs:label "Implements";
	rdfs:domain :Program;
	rdfs:range :MathematicalThing.

:implementationLanguage      a owl:DatatypeProperty;
	rdfs:comment "This property relates an instance of Program with a string indicating the programming language in which it was coded.";
	rdfs:label "Implementation Language";
	rdfs:domain :Program;
	rdfs:range <http://www.w3.org/2001/XMLSchema#string>.

:implementationURL      a owl:DatatypeProperty;
	rdfs:comment "This property relates an instance of Program with a URL at which the program can be found.";
	rdfs:label "Implementation URL";
	rdfs:domain :Program;
	rdfs:range <http://www.w3.org/2001/XMLSchema#anyURI>.



:ComplexityMeasure a owl:Class;
	rdfs:subClassOf :Definition;
	rdfs:comment "Complexity Measure".

:Omega			a :ComplexityMeasure;
	rdfs:comment "A theoretical measure of the execution of an algorithm, usually the time or memory needed, given the problem size $n$, which is usually the number of items.  Informally, saying some equation $f(n) = \\omega (g(n))$ means $g(n)$ becomes insignificant relative to $f(n)$ as $n$ goes to infinity.  ";
	rdfs:label "Omega".

:Sim			a :ComplexityMeasure;
	rdfs:comment "(1) Proportional to.  (2) Asymptotically equal to.  A theoretical measure of the execution of an algorithm, usually the time or memory needed, given the problem size $n$, which is usually the number of items.  Informally, saying some equation $f(n) \\sim g(n)$ means it grows at the same rate as $g(n)$. More formally, it means  $lim<sub>x \\rightarrow \\infty</sub>f(x)/g(x) = 1$.";
	rdfs:label "Sim".

:Theta			a :ComplexityMeasure;
	rdfs:comment "A theoretical measure of the execution of an algorithm, usually the time or memory needed, given the problem size $n$, which is usually the number of items.  Informally, saying some equation $f(n) = \\Theta (g(n))$ means it is within a constant multiple of g(n).  The equation is read, \"f of n is theta g of n\".";
	rdfs:label "Theta".


:RhoApproximationAlgorithm	a :AlgorithmicTechnique;
	rdfs:comment "An approximation algorithm guaranteed to find a solution at most (or at least, as appropriate) $\\rho$ times the optimum. The ratio $\\rho$ is the performance ratio or relative performance guarantee of the algorithm.";
	rdfs:subClassOf :ApproximationAlgorithm;
	rdfs:label "rho-approximation algorithm".

:ABTree				a :DataStructure;
	rdfs:comment "A search tree with the restrictions that all leaves are at the same depth and all internal nodes have between $a$ and $b$ children, where $a$ and $b$ are integers such that  $2 \\leq a \\leq (b+1)/2$.   The root may have as few as 2 children.";
	rdfs:subClassOf :SearchTree;
	rdfs:label "(a,b)-tree".

:AckermannsFunction		a :Algorithm;
	rdfs:comment "A function of two parameters whose value grows very fast.";
	rdfs:label "Ackermann's function".

:AckermannsFunctionImplementation1 a :Program;
	:implements :AckermannsFunction;
	:implementationLanguage "Modula-2";
	:implementationURL <http://www.modulaware.com/mdlt08.htm>.

:AckermannsFunctionImplementation2 a :Program;
	:implements :AckermannsFunction;
	:implementationLanguage "Lisp";
	:implementationURL <http://www.kosara.net/thoughts/ackermann.html>.

:AckermannsFunctionImplementation3 a :Program;
	:implements :AckermannsFunction;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.geocities.com/hjsmithh/Ackerman.html>.

:AckermannsFunctionImplementation4 a :Program;
	:implements :AckermannsFunction;
	:implementationLanguage "Miranda";
	:implementationURL <http://www.engin.umd.umich.edu/CIS/course.des/cis400/miranda/Ack.htm>.

:ActiveDataStructure		a :DataStructure;
	rdfs:comment "A data structure with an associated thread or process that performs internal operations to give the external behavior of another, usually more general, data structure.";
	rdfs:subClassOf :DataStructure;
	rdfs:label "active data structure".

:AdaptiveHeapSort		a :Algorithm;
	rdfs:comment "A variant of heapsort that uses a  randomized binary search tree (RBST) to structure the input according to any preexisting order.  The RBST is used to select candidates that are put into the heap so the heap doesn't need to  keep track of all elements.";
	rdfs:label "adaptive heap sort".

:AdaptiveHuffmanCoding		a :Algorithm;
	rdfs:comment "A near-minimal variable-length character coding that changes based on the frequency of characters processed.  As characters are processed, frequencies are updated and codes are changed (or, the coding tree is modified).";
	rdfs:subClassOf :HuffmanCoding;
	rdfs:label "adaptive Huffman coding".

:AdaptiveHuffmanCodingImplementation1 a :Program;
	:implements :AdaptiveHuffmanCoding;
	:implementationLanguage "C";
	:implementationURL <http://www.xcf.berkeley.edu/~ali/K0D/Algorithms/huff/>.

:AdaptiveKDTree			a :DataStructure;
	rdfs:comment "A tree for multidimensional points where successive levels may be split along different dimensions.";
	rdfs:subClassOf :Tree;
	rdfs:label "adaptive k-d tree".

:AddressCalculationSort		a :Algorithm;
	rdfs:comment "A sort algorithm which uses knowledge of the domain of the items to calculate the position of each item in the sorted array.";
	rdfs:subClassOf :Sort;
	rdfs:label "address-calculation sort".

:AdjacencyListRepresentation	a :DataStructure;
	rdfs:comment "A representation of a directed graph with $n$ vertices using an array of $n$ lists of vertices.  List $i$ contains vertex $j$ if there is an edge from vertex $i$ to vertex $j$.  A weighted graph may be represented with a list of vertex/weight pairs.  An undirected graph may be represented by having vertex $j$ in the list for vertex $i$ and vertex $i$ in the list for vertex $j$.";
	rdfs:label "adjacency-list representation".

:AdjacencyMatrixRepresentation	a :DataStructure;
	rdfs:comment "A representation of a directed graph with $n$ vertices using an $n \\times n$ matrix, where the entry at $(i,j)$ is 1 if there is an edge from vertex $i$ to vertex $j$; otherwise the entry is 0.  A weighted graph may be represented using the weight as the entry.  An undirected graph may be represented using the same entry in both $(i,j)$ and $(j,i)$ or using an upper triangular matrix.";
	rdfs:label "adjacency-matrix representation".

:AlgorithmFGK			a :Algorithm;
	rdfs:comment "An adaptive Huffman coding scheme.  Coding is never much worse than twice optimal.";
	rdfs:subClassOf :AdaptiveHuffmanCoding;
	rdfs:label "algorithm FGK".

:AmericanFlagSort		a :Algorithm;
	rdfs:comment "An efficient, in-place variant of radix sort that distributes items into hundreds of buckets.   The first step counts the number of items in each bucket, and the second step computes where each bucket will start in the array.  The last step cyclically permutes items to their proper bucket.  Since the buckets are in order in the array, there is no collection step. The name comes by analogy with the Dutch national flag problem in the last step: efficiently partition the array into many \"stripes\". Using some efficiency techniques, it is twice as fast as quicksort for large sets of strings.";
	rdfs:subClassOf :InPlaceSort;
	rdfs:label "American flag sort".

:AmericanFlagSortImplementation1 a :Program;
	:implements :AmericanFlagSort;
	:implementationLanguage "C";
	:implementationURL <http://goanna.cs.rmit.edu.au/~rsinha/resources/source/allsorts/mbmradix.c>.

:AmericanFlagSortImplementation2 a :Program;
	:implements :AmericanFlagSort;
	:implementationLanguage "C";
	:implementationURL <http://citeseer.ist.psu.edu/mcilroy93engineering.html>.

:ApproximationAlgorithm		a :AlgorithmicTechnique;
	rdfs:comment "An algorithm to solve an optimization problem that runs in polynomial time in the length of the input and outputs a solution that is guaranteed to be close to the optimal solution.  ``Close'' has some well-defined sense called the performance guarantee.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "approximation algorithm".

:ArithmeticCoding		a :Algorithm;
	rdfs:comment "A minimal variable-length message coding based on the frequency of each character.  The message is represented by a fraction which is the repeated offset-plus-product reduction of the range (offset) and probability (product) of each character.";
	rdfs:label "arithmetic coding".

:ArithmeticCodingImplementation1 a :Program;
	:implements :ArithmeticCoding;
	:implementationLanguage "C";
	:implementationURL <http://dogma.net/markn/articles/arith/part1.htm>.

:Array				a :DataStructure;
	rdfs:comment "A set of items which are randomly accessible by numeric index.";
	:aggregateChild :ArrayIndex;
	:aggregateChild :OneBasedIndexing;
	:aggregateChild :ZeroBasedIndexing;
	rdfs:label "array".

:ArrayImplementation1 a :Program;
	:implements :Array;
	:implementationLanguage "C";
	:implementationURL <http://ciips.ee.uwa.edu.au/~morris/Year2/PLDS210/arrays.html#arrays>.

:ArrayImplementation2 a :Program;
	:implements :Array;
	:implementationLanguage "Fortran";
	:implementationURL <http://gams.nist.gov/serve.cgi/Class/N1>.

:ArrayImplementation3 a :Program;
	:implements :Array;
	:implementationLanguage "C++";
	:implementationURL <http://gams.nist.gov/serve.cgi/Class/N1>.

:ArrayMerging			a :Algorithm;
	rdfs:comment "Joining two arrays into one.";
	rdfs:label "array merging".

:AssociativeArray		a :DataStructure;
	rdfs:comment "A collection of items that are randomly accessible by a key, often a string.";
	rdfs:label "associative array".

:AVLTree			a :DataStructure;
	rdfs:comment "A balanced binary search tree where the height of the two subtrees (children) of a node differs by at most one. Look-up, insertion, and deletion are O($\\log n$), where $n$ is the number of nodes in the tree.";
	rdfs:subClassOf :HeightBalancedTree;
	rdfs:subClassOf :BalancedBinaryTree;
	rdfs:subClassOf :BinarySearchTree;
	rdfs:subClassOf :RedBlackTree;
	:aggregateChild :LeftRotation;
	:aggregateChild :RightRotation;
	rdfs:label "AVL tree".

:AVLTreeImplementation1 a :Program;
	:implements :AVLTree;
	:implementationLanguage "C";
	:implementationURL <http://www.stanford.edu/~blp/avl/>.

:AVLTreeImplementation2 a :Program;
	:implements :AVLTree;
	:implementationLanguage "C";
	:implementationURL <http://users.footprints.net/~kaz/austin.html>.

:AVLTreeImplementation3 a :Program;
	:implements :AVLTree;
	:implementationLanguage "WOOP/ADA";
	:implementationURL <http://www.auto.tuwien.ac.at/~blieb/woop/avl.html>.

:Backtracking			a :AlgorithmicTechnique;
	rdfs:comment "Find a solution by trying one of several choices.  If the choice proves incorrect, computation <em>backtracks</em> or restarts at the point of choice and tries another choice.  It is often convenient to maintain choice points and alternate choices using recursion.";
	rdfs:label "backtracking".

:Bag				a :AbstractDataType;
	rdfs:comment "An unordered collection of values that may have duplicates.";
	rdfs:subClassOf :AbstractDataType;
	rdfs:label "bag".

:BalancedBinarySearchTree	a :DataStructure;
	rdfs:comment "A binary search tree that is balanced.";
	rdfs:subClassOf :BalancedBinaryTree;
	rdfs:subClassOf :BinarySearchTree;
	rdfs:label "balanced binary search tree".

:BalancedBinaryTree		a :DataStructure;
	rdfs:comment "A binary tree where no leaf is more than a certain amount farther from the root than any other.  After inserting or deleting a node, the tree may rebalanced with \"rotations.\"";
	rdfs:subClassOf :BinaryTree;
	:aggregateChild :LeftRotation;
	:aggregateChild :RightRotation;
	rdfs:label "balanced binary tree".

:BalancedBinaryTreeImplementation1 a :Program;
	:implements :BalancedBinaryTree;
	:implementationLanguage "C";
	:implementationURL <http://ciips.ee.uwa.edu.au/~morris/Year2/PLDS210/red_black.html>.

:BalancedBinaryTreeImplementation2 a :Program;
	:implements :BalancedBinaryTree;
	:implementationLanguage "C";
	:implementationURL <http://www.stanford.edu/~blp/avl/>.

:BalancedKWayMergeSort		a :Algorithm;
	rdfs:comment "A merge sort that sorts a data stream using repeated merges.  It distributes the input into $k$ streams by repeatedly reading a block of input that fits in memory, called a <em>run</em>, sorting it, then writing it to the next stream.  It then repeatedly merges the $k$ streams and puts each merged run into one of $j$ output streams until there is a single sorted output.";
	rdfs:subClassOf :MergeSort;
	rdfs:label "balanced k-way merge sort".

:BalancedMergeSort		a :Algorithm;
	rdfs:comment "A k-way merge sort in which the number of input and  output data streams is the same.  See balanced k-way merge sort.";
	rdfs:subClassOf :KWayMergeSort;
	rdfs:label "balanced merge sort".

:BalancedMergeSortImplementation1 a :Program;
	:implements :BalancedMergeSort;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/442.sort.c>.

:BalancedQuicksort		a :Algorithm;
	rdfs:comment "A variant of quicksort which attempts to choose a pivot likely to represent the middle of the values to be sorted.";
	rdfs:label "balanced quicksort".

:BalancedTree			a :DataStructure;
	rdfs:comment "A tree where no leaf is much farther away from the  root than any other leaf.  Different balancing schemes allow different definitions of \"much farther\" and different amounts of work to keep them balanced.";
	rdfs:subClassOf :Tree;
	rdfs:label "balanced tree".

:BalancedTwoWayMergeSort	a :Algorithm;
	rdfs:comment "A balanced k-way merge sort that sorts a data stream using repeated merges.  It distributes the input into two streams by repeatedly reading a block of input that fits in memory, a <em>run</em>, sorting it, then writing it to the next stream.  It then repeatedly merges the two streams and puts each merged run into one of two output streams until there is a single sorted output.";
	rdfs:subClassOf :BalancedKWayMergeSort;
	rdfs:label "balanced two-way merge sort".

:BANGFile			a :DataStructure;
	rdfs:comment "A balanced and nested grid (BANG) file is a point access method which divides space into a nonperiodic grid.  Each spatial dimension is divided by a  linear hash.  Cells may intersect, and points may be distributed between them.";
	rdfs:label "BANG file".

:BaruvkasAlgorithm		a :Algorithm;
	rdfs:comment "Compute a minimum spanning tree.";
	rdfs:label "Baruvka's algorithm".

:BaumWelchAlgorithm		a :Algorithm;
	rdfs:comment "An algorithm to find hidden Markov model parameters A, B, and $\\Pi$ with the maximum likelihood of generating the given symbol sequence in the observation vector.";
	:aggregateChild :HiddenMarkovModel;
	rdfs:label "Baum Welch algorithm".

:BBAlphaTree			a :DataStructure;
	rdfs:comment "A binary tree where the balance of every subtree,  $\\rho(T')$, is bounded by $\\alpha \\leq \\rho(T') \\leq 1-\\alpha$.";
	rdfs:subClassOf :BinaryTree;
	rdfs:label "BB(alpha) tree".

:BBAlphaTreeImplementation1 a :Program;
	:implements :BBAlphaTree;
	:implementationLanguage "WOOP/ADA";
	:implementationURL <http://www.auto.tuwien.ac.at/~blieb/woop/euclid.html>.

:BBAlphaTreeImplementation2 a :Program;
	:implements :BBAlphaTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3414.ins.c>.

:BBAlphaTreeImplementation3 a :Program;
	:implements :BBAlphaTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3414.ins.c>.

:BBAlphaTreeImplementation4 a :Program;
	:implements :BBAlphaTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3414.lrot.c>.

:BBAlphaTreeImplementation5 a :Program;
	:implements :BBAlphaTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3414.lrot.c>.

:BBAlphaTreeImplementation6 a :Program;
	:implements :BBAlphaTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3414.rrot.c>.

:BBAlphaTreeImplementation7 a :Program;
	:implements :BBAlphaTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3414.rrot.c>.

:BDTree				a :DataStructure;
	rdfs:comment "A binary tree that organizes multidimensional points by splitting off regular subintervals.";
	rdfs:subClassOf :BinaryTree;
	rdfs:subClassOf :PointAccessMethod;
	rdfs:label "BD-tree".

:BellmanFordAlgorithm		a :Algorithm;
	rdfs:comment "An efficient algorithm to solve the single-source shortest-path problem. Weights may be negative.   The algorithm initializes the distance to the source vertex to 0 and all other vertices to $\\infty$.  It then does $V-1$ passes (V is the number of vertices) over all edges relaxing, or updating, the distance to the destination of each edge. Finally it checks each edge again to detect negative weight cycles, in which case it returns false.  The time complexity is O(VE), where E is the number of edges.";
	rdfs:label "Bellman-Ford algorithm".

:BellmanFordAlgorithmImplementation1 a :Program;
	:implements :BellmanFordAlgorithm;
	:implementationLanguage "C";
	:implementationURL <http://en.wikipedia.org/wiki/Bellman-Ford_algorithm>.

:BellmanFordAlgorithmImplementation2 a :Program;
	:implements :BellmanFordAlgorithm;
	:implementationLanguage "Assembly";
	:implementationURL <http://en.wikipedia.org/wiki/Bellman-Ford_algorithm>.

:BellmanFordAlgorithmImplementation3 a :Program;
	:implements :BellmanFordAlgorithm;
	:implementationLanguage "pseudocode";
	:implementationURL <http://en.wikipedia.org/wiki/Bellman-Ford_algorithm>.

:BestFirstSearch		a :Algorithm;
	rdfs:comment "A state-space search algorithm that considers the estimated best partial solution next.  This is typically implemented with a priority queue.";
	rdfs:label "best-first search".

:BidirectionalBubbleSort	a :Algorithm;
	rdfs:comment "A variant of bubble sort which compares each adjacent pairs of items in a list in turn, swapping them if necessary, and alternately passes through the list from the beginning to the end then from the end to the beginning until no swaps are done.";
	rdfs:label "bidirectional bubble sort".

:BidirectionalBubbleSortImplementation1 a :Program;
	:implements :BidirectionalBubbleSort;
	:implementationLanguage "Java";
	:implementationURL <http://java.sun.com/applets/jdk/1.0/demo/SortDemo/example1.html>.

:BidirectionalBubbleSortImplementation2 a :Program;
	:implements :BidirectionalBubbleSort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.ubc.ca/spider/harrison/Java/sorting-demo.html>.

:BidirectionalBubbleSortImplementation3 a :Program;
	:implements :BidirectionalBubbleSort;
	:implementationLanguage "Java";
	:implementationURL <http://cg.scs.carleton.ca/~morin/misc/sortalg/>.

:BinaryGCDAlgorithm		a :Algorithm;
	rdfs:comment "Compute the greatest common divisor of two integers, $u$ and $v$, expressed in binary.  The run time complexity is $O((\\log<sub>2</sub> u v)<sup>2</sup>)$ bit operations.";
	rdfs:label "binary GCD algorithm".

:BinaryHeap			a :DataStructure;
	rdfs:comment "A complete binary tree where every node has a key more extreme (greater or less) than or equal to the key of its  parent.";
	rdfs:subClassOf :CompleteBinaryTree;
	rdfs:subClassOf :Heap;
	rdfs:subClassOf :KAryHeap;
	:aggregateChild :Array;
	rdfs:label "binary heap".

:BinaryHeapImplementation1 a :Program;
	:implements :BinaryHeap;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/513.del.c>.

:BinaryHeapImplementation2 a :Program;
	:implements :BinaryHeap;
	:implementationLanguage "C";
	:implementationURL <http://ciips.ee.uwa.edu.au/~morris/Year2/PLDS210/heaps.html>.

:BinaryHeapImplementation3 a :Program;
	:implements :BinaryHeap;
	:implementationLanguage "Fortran";
	:implementationURL <http://gams.nist.gov/serve.cgi/ModuleComponent/8600/Fullsource/NETLIB/561>.

:BinaryInsertionSort		a :Algorithm;
	rdfs:comment "Insertion sort in which the proper location for the next item is found with a binary search.";
	rdfs:label "binary insertion sort".

:BinaryInsertionSortImplementation1 a :Program;
	:implements :BinaryInsertionSort;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/412c.sort.c>.

:BinaryPriorityQueue		a :DataStructure;
	rdfs:comment "A priority queue implemented with a binary tree having the following restrictions: <ul> <li>The key of a node is greater than keys of its children, i.e., it has the heap property. <li>If the right subtree is not empty, the left subtree is not empty. <li>If there are both left and right children, the left child's key is greater than the right child's key.  </ul>";
	rdfs:subClassOf :PriorityQueue;
	:aggregateChild :BinaryTree;
	:aggregateChild :HeapProperty;
	rdfs:label "binary priority queue".

:BinaryPriorityQueueImplementation1 a :Program;
	:implements :BinaryPriorityQueue;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/516b.ins.c>.

:BinaryPriorityQueueImplementation2 a :Program;
	:implements :BinaryPriorityQueue;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/516b.ins.c>.

:BinarySearch			a :Algorithm;
	rdfs:comment "Search a sorted array by repeatedly dividing the search interval in half.  Begin with an interval covering the whole array. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half.  Otherwise narrow it to the upper half.  Repeatedly check until the value is found or the interval is empty.";
	rdfs:subClassOf :DichotomicSearch;
	rdfs:label "binary search".

:BinarySearchImplementation1 a :Program;
	:implements :BinarySearch;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/321.srch.c>.

:BinarySearchTree		a :DataStructure;
	rdfs:comment "A binary tree where every node's left  subtree has keys less than the node's key, and every right subtree has keys greater than the node's key.";
	rdfs:subClassOf :BinaryTree;
	rdfs:subClassOf :SearchTree;
	rdfs:label "binary search tree".

:BinarySearchTreeImplementation1 a :Program;
	:implements :BinarySearchTree;
	:implementationLanguage "literate C";
	:implementationURL <http://www.stanford.edu/~blp/avl/libavl.html/Binary-Search-Trees.html>.

:BinarySearchTreeImplementation2 a :Program;
	:implements :BinarySearchTree;
	:implementationLanguage "C";
	:implementationURL <http://users.footprints.net/~kaz/austin.html>.

:BinarySearchTreeImplementation3 a :Program;
	:implements :BinarySearchTree;
	:implementationLanguage "C";
	:implementationURL <http://www.cse.ucsc.edu/classes/cmps012b/Spring97/Lecture16/sld013.htm>.

:BinarySearchTreeImplementation4 a :Program;
	:implements :BinarySearchTree;
	:implementationLanguage "Lisp";
	:implementationURL <http://www.cs.oberlin.edu/classes/dragn/labs/avl/avl30.html>.

:BinarySearchTreeImplementation5 a :Program;
	:implements :BinarySearchTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3411.ins.c>.

:BinarySearchTreeImplementation6 a :Program;
	:implements :BinarySearchTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3411.srch.c>.

:BinarySearchTreeImplementation7 a :Program;
	:implements :BinarySearchTree;
	:implementationLanguage "Modula-2";
	:implementationURL <http://www.csc.twu.ca/rsbook/index.html?http://www.csc.twu.ca/rsbook/Ch14/Ch14.8.html>.

:BinaryTree			a :DataStructure;
	rdfs:comment "A tree with at most two children for each  node.";
	rdfs:subClassOf :Tree;
	rdfs:subClassOf :MultiwayTree;
	rdfs:subClassOf :KAryTree;
	rdfs:label "binary tree".

:BinaryTreeImplementation1 a :Program;
	:implements :BinaryTree;
	:implementationLanguage "C";
	:implementationURL <http://ciips.ee.uwa.edu.au/~morris/Year2/PLDS210/trees.html>.

:BinaryTreeImplementation2 a :Program;
	:implements :BinaryTree;
	:implementationLanguage "WOOP/ADA";
	:implementationURL <http://www.auto.tuwien.ac.at/~blieb/woop/bintree.html>.

:BinaryTreeRepresentationOfTrees	a :DataStructure;
	rdfs:comment "A way to represent a multiway tree as a binary tree.  The leftmost child, $c$, of a node, $n$, in the multiway tree is the left child, $c'$, of the corresponding node, $n'$, in the binary tree. The immediately right sibling of $c$ is the right child of $c'$.";
	rdfs:label "binary tree representation of trees".

:BingoSort			a :Algorithm;
	rdfs:comment "A variant of selection sort that orders items by repeatedly looking through remaining items to find the greatest value and moving all items with that value to their final location.  This is more efficient if there are many duplicate values.";
	rdfs:label "bingo sort".

:BinomialHeap			a :DataStructure;
	rdfs:comment "A priority queue made of a forest of binomial trees with the heap property numbered $k=0, 1, 2, \\ldots, n$, each containing either 0 or $2<sup>k</sup>$ nodes. Each tree is formed by linking two of its predecessors, by joining one at the root of the other.  The operations of insert a value, decrease a value, delete a value, and merge or join (meld) two queues take $O(\\log n)$ time.  The find minimum operation is a constant $\\Theta(1)$.";
	rdfs:subClassOf :PriorityQueue;
	rdfs:label "binomial heap".

:BinomialTree			a :DataStructure;
	rdfs:comment "An ordered tree of order $k \\geq 0$, that is $B<sub>k</sub>$, has a root with $k$ children where the $i<sup>th</sup>$ child is binomial tree of order $k-i$.";
	rdfs:subClassOf :OrderedTree;
	rdfs:label "binomial tree".

:Bintree			a :DataStructure;
	rdfs:comment "A regular decomposition k-d tree for region data.";
	rdfs:subClassOf :RegularDecomposition;
	rdfs:label "bintree".

:BitonicSort			a :Algorithm;
	rdfs:comment "Compare, and swap if necessary, pairs of elements in parallel. Subsets are sorted then merged.";
	rdfs:label "bitonic sort".

:BitonicSortImplementation1 a :Program;
	:implements :BitonicSort;
	:implementationLanguage "Java";
	:implementationURL <http://www.iti.fh-flensburg.de/lang/algorithmen/sortieren/bitonic/bitonicen.htm>.

:BitonicSortImplementation2 a :Program;
	:implements :BitonicSort;
	:implementationLanguage "C";
	:implementationURL <http://www.cag.lcs.mit.edu/streamit/results/bitonic/code/c/>.

:BitVector			a :DataStructure;
	rdfs:comment "An array of bits.";
	rdfs:subClassOf :Array;
	rdfs:label "bit vector".

:BkTree				a :DataStructure;
	rdfs:comment "A binomial tree of order (height) $k$.";
	rdfs:subClassOf :BinomialTree;
	rdfs:label "B<sub>k</sub> tree".

:BlockAddressingIndex		a :DataStructure;
	rdfs:comment "An inverted index which includes the block, or general location, within texts, in addition to the text in which the word appears.";
	rdfs:subClassOf :InvertedIndex;
	rdfs:label "block addressing index".

:BloomFilter			a :Algorithm;
	rdfs:comment "A probabilistic algorithm to quickly test membership in a large set using multiple hash functions into a single  array of bits.";
	rdfs:subClassOf :ProbabilisticAlgorithm;
	rdfs:label "Bloom filter".

:Bogosort			a :Algorithm;
	rdfs:comment "A terribly inefficient sort algorithm that repeatedly generates a random permutation of the items until the items are in order.";
	rdfs:label "bogosort".

:BoundedQueue			a :DataStructure;
	rdfs:comment "A queue limited to a fixed number of items.";
	rdfs:subClassOf :Queue;
	rdfs:label "bounded queue".

:BoundedStack			a :DataStructure;
	rdfs:comment "A stack limited to a fixed number of items.";
	rdfs:subClassOf :Stack;
	rdfs:label "bounded stack".

:BoyerMoore			a :Algorithm;
	rdfs:comment "A string matching algorithm that compares characters from the end of the pattern to its beginning.  When characters don't match, searching jumps to the next possible match: the farthest of a table like that used in the Knuth-Morris-Pratt algorithm and the next matching position in the pattern.";
	rdfs:subClassOf :StringMatching;
	rdfs:label "Boyer-Moore".

:BoyerMooreImplementation1 a :Program;
	:implements :BoyerMoore;
	:implementationLanguage "C";
	:implementationURL <http://www-igm.univ-mlv.fr/~lecroq/string/node14.html>.

:BoyerMooreImplementation2 a :Program;
	:implements :BoyerMoore;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/713a.srch.c>.

:BoyerMooreHorspool		a :Algorithm;
	rdfs:comment "A string matching algorithm that compares characters from the end of the pattern to its beginning.  When characters don't match, searching jumps to the next matching position in the pattern.";
	rdfs:subClassOf :StringMatching;
	rdfs:label "Boyer-Moore-Horspool".

:BoyerMooreHorspoolImplementation1 a :Program;
	:implements :BoyerMooreHorspool;
	:implementationLanguage "C";
	:implementationURL <http://www-igm.univ-mlv.fr/~lecroq/string/node18.html>.

:BoyerMooreHorspoolImplementation2 a :Program;
	:implements :BoyerMooreHorspool;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/713b.srch.c>.

:BozoSort			a :Algorithm;
	rdfs:comment "A terribly inefficient sort algorithm that randomly swaps items until they are in order.";
	rdfs:label "bozo sort".

:BozoSortImplementation1 a :Program;
	:implements :BozoSort;
	:implementationLanguage "Java";
	:implementationURL <http://cg.scs.carleton.ca/~morin/misc/sortalg/>.

:BPlusTree			a :DataStructure;
	rdfs:comment "A B-tree in which keys are stored in the  leaves.";
	rdfs:subClassOf :BTree;
	rdfs:label "B+-tree".

:BranchAndBound			a :AlgorithmicTechnique;
	rdfs:comment "An algorithmic technique to find the optimal solution by keeping the best solution found so far.  If a partial solution cannot improve on the best, it is abandoned.";
	rdfs:label "branch and bound".

:BreadthFirstSearch		a :Algorithm;
	rdfs:comment "A search algorithm that considers neighbors of a vertex, that is, outgoing edges of the vertex's predecessor in the search, before any outgoing edges of the vertex.  Extremes are searched last.  This is typically implemented with a queue.";
	rdfs:label "breadth-first search".

:BreadthFirstSearchImplementation1 a :Program;
	:implements :BreadthFirstSearch;
	:implementationLanguage "Lisp";
	:implementationURL <http://yoda.cis.temple.edu:8080/UGAIWWW/books/knight/bfs.html>.

:BreadthFirstSearchImplementation2 a :Program;
	:implements :BreadthFirstSearch;
	:implementationLanguage "Prolog";
	:implementationURL <http://yoda.cis.temple.edu:8080/UGAIWWW/books/shoham/chapter2/section2.5.html>.

:BresenhamsAlgorithm		a :Algorithm;
	rdfs:comment "An efficient algorithm to render a line with pixels.  The long dimension is incremented for each pixel, and the fractional slope is accumulated.";
	rdfs:label "Bresenham's algorithm".

:BresenhamsAlgorithmImplementation1 a :Program;
	:implements :BresenhamsAlgorithm;
	:implementationLanguage "Autocoder";
	:implementationURL <http://www.bitsavers.org/1401/progs/bresenham/bresenham.s>.

:BritishMuseumTechnique		a :AlgorithmicTechnique;
	rdfs:comment "Find a solution by checking all possibilities one by one, beginning with the smallest.  This is a conceptual, not a practical, technique where the number of possibilities are enormous.";
	rdfs:subClassOf :ExhaustiveSearch;
	rdfs:subClassOf :BreadthFirstSearch;
	rdfs:label "British Museum technique".

:BruteForce			a :AlgorithmicTechnique;
	rdfs:comment "An algorithm that inefficiently solves a problem, often by trying every one of a wide range of possible solutions.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "brute force".

:BruteForceStringSearch		a :Algorithm;
	rdfs:comment "An algorithm to find a string within another string or body of text by trying each position one at a time.  There are many far faster string matching algorithms.";
	rdfs:label "brute force string search".

:BruteForceStringSearchImplementation1 a :Program;
	:implements :BruteForceStringSearch;
	:implementationLanguage "C";
	:implementationURL <http://www-igm.univ-mlv.fr/~lecroq/string/>.

:BruteForceStringSearchImplementation2 a :Program;
	:implements :BruteForceStringSearch;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/711a.srch.c>.

:BruteForceStringSearchImplementation3 a :Program;
	:implements :BruteForceStringSearch;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/711a.srch.c>.

:BruteForceStringSearchWithMismatches	a :Algorithm;
	rdfs:comment "Beginning with the (leftmost) position in a string and trying each position in turn, find the number of characters for which the pattern and the substring beginning at that position don't match (the Hamming distance).  Return the first position with $k$ or fewer mismatches.";
	rdfs:subClassOf :StringMatchingWithMismatches;
	rdfs:subClassOf :BruteForceStringSearch;
	rdfs:label "brute force string search with mismatches".

:BruteForceStringSearchWithMismatchesImplementation1 a :Program;
	:implements :BruteForceStringSearchWithMismatches;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/718.srch.c>.

:BruteForceStringSearchWithMismatchesImplementation2 a :Program;
	:implements :BruteForceStringSearchWithMismatches;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/718.srch.c>.

:BSPTree			a :DataStructure;
	rdfs:comment "A binary space partitioning (BSP) tree is a binary tree for multidimensional points where successive levels are split by arbitrary hyperplanes.";
	rdfs:label "BSP-tree".

:BStarTree			a :DataStructure;
	rdfs:comment "A B-tree in which nodes are kept 2/3 full by redistributing keys to fill two child nodes, then splitting them into three nodes.";
	rdfs:subClassOf :BTree;
	rdfs:label "B*-tree".

:BStarTreeImplementation1 a :Program;
	:implements :BStarTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/342.data.c>.

:BStarTreeImplementation2 a :Program;
	:implements :BStarTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/342.data.c>.

:BStarTreeImplementation3 a :Program;
	:implements :BStarTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/342.ins.c>.

:BStarTreeImplementation4 a :Program;
	:implements :BStarTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/342.ins.c>.

:BStarTreeImplementation5 a :Program;
	:implements :BStarTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/342.srch.c>.

:BStarTreeImplementation6 a :Program;
	:implements :BStarTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/342.srch.c>.

:BTree				a :DataStructure;
	rdfs:comment "A balanced search tree in which every node has between $\\lceil m/2\\rceil$ and $m$ children, where $m&gt;1$ is a fixed integer.  $m$ is the order.  The root may have as few as 2 children. This is a good structure if much of the tree is in slow memory (disk), since the height, and hence the number of accesses, can be kept small, say one or two, by picking a large $m$.";
	rdfs:subClassOf :BalancedTree;
	rdfs:subClassOf :SearchTree;
	rdfs:label "B-tree".

:BTreeImplementation1 a :Program;
	:implements :BTree;
	:implementationLanguage "Perl";
	:implementationURL <http://perl.plover.com/BTree/>.

:BTreeImplementation2 a :Program;
	:implements :BTree;
	:implementationLanguage "C++";
	:implementationURL <http://cis.stvincent.edu/carlsond/swdesign/btree/btree.html>.

:BTreeImplementation3 a :Program;
	:implements :BTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/342.data.c>.

:BTreeImplementation4 a :Program;
	:implements :BTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/342.data.c>.

:BTreeImplementation5 a :Program;
	:implements :BTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/342.ins.c>.

:BTreeImplementation6 a :Program;
	:implements :BTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/342.ins.c>.

:BTreeImplementation7 a :Program;
	:implements :BTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/342.srch.c>.

:BTreeImplementation8 a :Program;
	:implements :BTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/342.srch.c>.

:BTreeImplementation9 a :Program;
	:implements :BTree;
	:implementationLanguage "Pick Basic?";
	:implementationURL <http://www.semaphorecorp.com/btp/btp.html>.

:BubbleSort			a :Algorithm;
	rdfs:comment "Sort by comparing each adjacent pair of items in a list in turn, swapping the items if necessary, and repeating the pass through the list until no swaps are done.";
	rdfs:subClassOf :InPlaceSort;
	rdfs:subClassOf :Sort;
	rdfs:label "bubble sort".

:BubbleSortImplementation1 a :Program;
	:implements :BubbleSort;
	:implementationLanguage "Java";
	:implementationURL <http://java.sun.com/applets/jdk/1.0/demo/SortDemo/example1.html>.

:BubbleSortImplementation2 a :Program;
	:implements :BubbleSort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.ubc.ca/spider/harrison/Java/sorting-demo.html>.

:BubbleSortImplementation3 a :Program;
	:implements :BubbleSort;
	:implementationLanguage "Rexx";
	:implementationURL <http://www.markcrocker.com/rexxtipsntricks/rxtt28.2.0469.html>.

:BubbleSortImplementation4 a :Program;
	:implements :BubbleSort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.hope.edu/~alganim/animator/Animator.html>.

:BucketArray			a :DataStructure;
	rdfs:comment "Implementation of a dictionary by an array indexed by the keys of the items in the dictionary.";
	rdfs:label "bucket array".

:BucketSort			a :Algorithm;
	rdfs:comment "A distribution sort where input elements are initially  distributed to several buckets based on an interpolation of the element's key. Each bucket is sorted if necessary, and the buckets' contents are concatenated.";
	rdfs:subClassOf :DistributionSort;
	rdfs:label "bucket sort".

:BucketSortImplementation1 a :Program;
	:implements :BucketSort;
	:implementationLanguage "C";
	:implementationURL <http://ciips.ee.uwa.edu.au/~morris/Year2/PLDS210/binsort.html>.

:BucketSortImplementation2 a :Program;
	:implements :BucketSort;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/423.sort.c>.

:BucketTrie			a :DataStructure;
	rdfs:comment "A variant of a trie in which leaf nodes are buckets which hold up to $k$ strings.  Usually implies fixed sized buckets.";
	rdfs:subClassOf :Trie;
	rdfs:label "bucket trie".

:BuddySystem			a :Algorithm;
	rdfs:comment "A memory allocation strategy which recursively divides allocatable blocks of memory into pairs of adjacent equal-sized blocks called \"buddies.\"";
	rdfs:label "buddy system".

:BuddyTree			a :DataStructure;
	rdfs:comment "A point access method which splits multidimensional space in different dimensions at each level.  It also keeps a minimum bounding box of points accessible by each node.";
	rdfs:subClassOf :PointAccessMethod;
	rdfs:label "buddy tree".

:BuildHeap			a :Algorithm;
	rdfs:comment "Convert an array into a heap by executing heapify progressively closer to the root.  For an array of $n$ nodes, this takes O(n) time under the comparison model.";
	rdfs:label "build-heap".

:BurrowsWheelerTransform	a :Algorithm;
	rdfs:comment "Rearrange a string so repeated substrings lead to repeated characters in the rearranged string, which is easier to compress. Knowing which character was last in the original string, the original can be reconstructed from the rearranged string.";
	:aggregateChild :Sort;
	rdfs:label "Burrows-Wheeler transform".

:BVTree				a :DataStructure;
	rdfs:comment "A conceptual idea which generalizes B-trees to multiple dimensions.  BV-trees are not balanced, and searching may require backtracking.";
	rdfs:label "BV-tree".

:CactusStack			a :DataStructure;
	rdfs:comment "A variant of stack in which one other cactus stack may be attached to the top.  An attached stack is called a ``branch.''  When a branch becomes empty, it is removed.  Pop is not allowed if there is a branch.  A branch is only accessible through the original reference; it is not accessible through the stack.";
	rdfs:subClassOf :Stack;
	rdfs:subClassOf :Tree;
	rdfs:label "cactus stack".

:CalendarQueue			a :DataStructure;
	rdfs:comment "A fast priority queue implementation having N buckets each with width w, or covering w time.  An item with priority p more than current goes in bucket (p/w)%N.   Choose N and w to have few items in each bucket.  Keep items sorted within buckets.  Double or halve N and change w if the number of items grows or shrinks a lot.";
	rdfs:subClassOf :PriorityQueue;
	rdfs:label "calendar queue".

:CalendarQueueImplementation1 a :Program;
	:implements :CalendarQueue;
	:implementationLanguage "C";
	:implementationURL <http://www.cise.ufl.edu/~fishwick/CPUDisk/queuing_code.html>.

:Caverphone			a :Algorithm;
	rdfs:comment "An algorithm to code English words phonetically.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "Caverphone".

:CaverphoneImplementation1 a :Program;
	:implements :Caverphone;
	:implementationLanguage "Python";
	:implementationURL <http://caversham.otago.ac.nz/files/working/ctp150804.pdf>.

:CaverphoneImplementation2 a :Program;
	:implements :Caverphone;
	:implementationLanguage "JavaScript";
	:implementationURL <http://caversham.otago.ac.nz/files/working/ctp060902.pdf>.

:CellTree			a :DataStructure;
	rdfs:comment "A spatial access method where successive levels are split by arbitrary hyperplanes.  Concave objects are decomposed into convex pieces.  Each convex piece is indexed in every cell which it overlaps.";
	rdfs:subClassOf :SpatialAccessMethod;
	rdfs:label "cell tree".

:Chaining			a :DataStructure;
	rdfs:comment "A class of collision resolution schemes in which  linked lists handle collisions in a hash table.  The two main subclasses are separate chaining, where lists are outside the table, and coalesced chaining, where the lists are within the table.";
	rdfs:subClassOf :CollisionResolutionScheme;
	:aggregateChild :LoadFactor;
	rdfs:label "chaining".

:ChainingImplementation1 a :Program;
	:implements :Chaining;
	:implementationLanguage "C";
	:implementationURL <http://burtleburtle.net/bob/hash/hashtab.html>.

:ChineseRemainderTheorem	a :Algorithm;
	rdfs:comment "An integer $n$ can be solved uniquely mod  LCM($A(i)$), given modulii ($n mod A(i)$), $A(i) &gt; 0$ for $i=1..k$, $k &gt; 0$. In other words, given the remainders an integer gets when it's divided by an arbitrary set of divisors, you can uniquely determine the integer's remainder when it is divided by the least common multiple of those divisors.";
	rdfs:label "Chinese remainder theorem".

:ChristofidesAlgorithm		a :Algorithm;
	rdfs:comment "(1) A heuristic algorithm to find a near-optimal solution to the traveling salesman problem.  Step 1: find a minimum spanning tree T.  Step 2: find a perfect matching M among vertices with odd degree.  Step 3: combine the edges of M and T to make a multigraph G.  Step 4: find an Euler cycle in G by skipping vertices already seen.  (2) An algorithm to find the chromatic number of a graph.";
	rdfs:subClassOf :Heuristic;
	:aggregateChild :MinimumSpanningTree;
	:aggregateChild :PerfectMatching;
	:aggregateChild :Multigraph;
	:aggregateChild :EulerCycle;
	rdfs:label "Christofides algorithm".

:CircularList			a :DataStructure;
	rdfs:comment "A variant of a linked list in which the nominal tail is linked to the head.  The entire list may be accessed starting at any item and following links until one comes to the starting item again.";
	rdfs:label "circular list".

:CircularQueue			a :DataStructure;
	rdfs:comment "An implementation of a bounded queue using an array.";
	rdfs:label "circular queue".

:CoalescedChaining		a :DataStructure;
	rdfs:comment "A scheme in which linked lists within the hash table handle collisions.  An item that collides is put in the next empty place in the array and added to the end of a list embedded in the array items.  Any open addressing method to compute possible new positions may be used to find the \"next\" empty place.";
	rdfs:subClassOf :Chaining;
	rdfs:subClassOf :CollisionResolutionScheme;
	rdfs:label "coalesced chaining".

:CoalescedChainingImplementation1 a :Program;
	:implements :CoalescedChaining;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3312.ins.c>.

:CoalescedChainingImplementation2 a :Program;
	:implements :CoalescedChaining;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3312.srch.c>.

:CollectiveRecursion		a :AlgorithmicTechnique;
	rdfs:comment "A special form of tail recursion, where the results are produced during the recursive calls and nothing is returned.  The recursion may be optimized away by executing the call in the current stack frame, rather than creating a new stack frame, or by deallocating the entire recursion stack at once rather than a little at each return.";
	rdfs:label "collective recursion".

:CollisionResolutionScheme	a :Algorithm;
	rdfs:comment "A way of handling collisions, that is, when two or more items should be kept in the same location, especially in a hash table. The general ways are keeping subsequent items within the table and computing possible locations (open addressing), keeping lists for items that collide (chaining), or keeping one special overflow area.";
	rdfs:label "collision resolution scheme".

:Combination			a :Algorithm;
	rdfs:comment "Choose $n$ of $m$ elements, where $n \\leq m$.";
	rdfs:label "combination".

:CombinationImplementation1 a :Program;
	:implements :Combination;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.theory.csc.uvic.ca/~cos/inf/comb/CombinationsInfo.html>.

:CombinationImplementation2 a :Program;
	:implements :Combination;
	:implementationLanguage "C";
	:implementationURL <http://www.theory.csc.uvic.ca/~cos/inf/comb/CombinationsInfo.html>.

:CombinationImplementation3 a :Program;
	:implements :Combination;
	:implementationLanguage "Java";
	:implementationURL <http://www.merriampark.com/comb.htm>.

:CombSort			a :Algorithm;
	rdfs:comment "An in-place sort algorithm that repeatedly reorders different pairs of items.  On each pass swap pairs of items separated by the increment or gap, $i$, if needed and reduce the gap (divide it by about 1.3).  The gap starts at about 3/4 of the number of items.  Continue until the gap is 1 and a pass had no swaps.";
	rdfs:subClassOf :DiminishingIncrementSort;
	rdfs:label "comb sort".

:CombSortImplementation1 a :Program;
	:implements :CombSort;
	:implementationLanguage "C";
	:implementationURL <http://world.std.com/~jdveale/combsort.htm>.

:CombSortImplementation2 a :Program;
	:implements :CombSort;
	:implementationLanguage "C++";
	:implementationURL <http://yagni.com/combsort/index.php>.

:CombSortImplementation3 a :Program;
	:implements :CombSort;
	:implementationLanguage "Ruby";
	:implementationURL <http://yagni.com/combsort/index.php>.

:CombSortImplementation4 a :Program;
	:implements :CombSort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.ubc.ca/spider/harrison/Java/CombSort11Algorithm.java>.

:CombSortImplementation5 a :Program;
	:implements :CombSort;
	:implementationLanguage "Java";
	:implementationURL <http://yagni.com/combsort/correspondence.php>.

:CompactDAWG			a :DataStructure;
	rdfs:comment "A directed acyclic word graph (DAWG) representing the suffixes of a given string in which each edge is labeled with the longest possible string.  The strings along a path from the root to a node are the substring which the node represents.";
	rdfs:subClassOf :DirectedAcyclicGraph;
	rdfs:label "compact DAWG".

:CompactTrie			a :DataStructure;
	rdfs:comment "A trie in which nonbranching subtrees leading to leaf nodes are cut off.";
	rdfs:subClassOf :Trie;
	rdfs:label "compact trie".

:CompleteBinaryTree		a :DataStructure;
	rdfs:comment "A binary tree in which every level, except possibly the deepest, is completely filled.  At depth $n$, the height of the tree, all nodes must be as far left as possible.  ";
	rdfs:subClassOf :CompleteTree;
	rdfs:subClassOf :BinaryTree;
	rdfs:label "complete binary tree".

:CompleteTree			a :DataStructure;
	rdfs:comment "A tree in which all leaf nodes are at some depth $n$ or $n-1$, and all leaves at depth n are toward the left.";
	rdfs:subClassOf :Tree;
	rdfs:label "complete tree".

:CORDIC				a :Algorithm;
	rdfs:comment "Compute trigonometric functions by iterative complex rotations. The advantage is that all computations can be done with addition, subtraction, and binary shifts.";
	rdfs:label "CORDIC".

:CORDICImplementation1 a :Program;
	:implements :CORDIC;
	:implementationLanguage "C";
	:implementationURL <http://www.dspguru.com/info/faqs/cordic.htm>.

:CORDICImplementation2 a :Program;
	:implements :CORDIC;
	:implementationLanguage "C";
	:implementationURL <http://www.worldserver.com/turk/computergraphics/FixedPointTrigonometry.pdf>.

:CountingSort			a :Algorithm;
	rdfs:comment "A 2-pass sort algorithm that is efficient when the range of keys is small and there many duplicate keys.  The first pass counts the occurrences of each key in an auxiliary array, and then makes a running total so each auxiliary entry is the number of preceding keys.  The second pass puts each item in its final place according to the auxiliary entry for that key.";
	rdfs:subClassOf :HistogramSort;
	rdfs:label "counting sort".

:CountingSortImplementation1 a :Program;
	:implements :CountingSort;
	:implementationLanguage "C++";
	:implementationURL <http://www.mcky.net/hsrto.htm>.

:CubeRoot			a :Algorithm;
	rdfs:comment "This describes a \"long hand\" or manual method of calculating or extracting cube roots.  Calculation of a cube root by hand is a little like long-hand division or manual square root. </p> <p> Suppose you need to find the cube root of 55,742,968. Set up a \"division\" with the number under the radical. Mark off triples of digits, starting from the decimal point.  (The decimal point is a period (.), and a comma (,) marks triples of digits.) <pre>          ____________	<br>        \\/ 55,742,968.	<br> </pre> Look at the leftmost digit(s) (55 in this case).  What is the largest number whose cube is less than or equal to it?  It is 3, whose cube is 27.  Write 3 above, write the cube below and subtract. <pre>          __3_________	<br>        \\/ 55,742,968.	<br>          -27		<br>          ----		<br>           28		<br> </pre> Now bring down the next three digits (742). <pre>          __3_________	<br>        \\/ 55,742,968.	<br>          -27		<br>          ----		<br>            28742	<br> </pre> Coming up with the next \"divisor\" is more involved than for  square roots.  First bring down 3 times the square of the number on top ($3 \\times 3<sup>2</sup>=27$) leaving room for two more digits (27__). <pre>          __3_________	<br>        \\/ 55,742,968.	<br>          -27		<br>          ----		<br>      27__) 28742	<br> </pre> What is the largest number that we can put in the next position and multiply times the divisor and still be less than or equal to what we have? (Algebraically, what is d such that $d \\times 2700 \\leq 28742$?) 10 might work (since $10 \\times 2700 = 27000$), but we can only use a single digit, so we'll try 9. <pre>          __3___9_____	<br>        \\/ 55,742,968.	<br>          -27		<br>          ----		<br>      27__) 28742	<br> </pre> The second step in making the divisor is adding 3 times the previous number on top (3) times the last digit (9) times 10 ($3 \\times 3 \\times 9 = 81 \\times 10 = 810$) and the square of the last digit ($9<sup>2</sup> = 81$). <pre>      2700	<br>       810	<br>     +  81	<br>     -----	<br>      3591	<br> </pre> Our new divisor is 3591.   <pre>          __3___9_____	<br>        \\/ 55,742,968.	<br>          -27		<br>          ----		<br>      3591) 28742	<br> </pre> Multiply by the last digit ($9 \\times 3591 = 32319$) and subtract.  But that is too big!  So we'll try 8 as the next digit instead. <pre>          __3___8_____	<br>        \\/ 55,742,968.	<br>          -27		<br>          ----		<br>      27__) 28742	<br> </pre> We repeat the second step of adding 3 times the previous number on top (3) times the last digit (8) times 10 ($3 \\times 3 \\times 8 = 72 \\times 10 = 720$) and the square of the last digit ($8<sup>2</sup> = 64$). <pre>      2700	<br>       720	<br>     +  64	<br>     -----	<br>      3484	<br> </pre> Our new divisor is 3484. <pre>          __3___8_____	<br>        \\/ 55,742,968.	<br>          -27		<br>          ----		<br>      3484) 28742	<br> </pre> Now multiply by the last digit ($8 \\times 3484 = 27872$) and subtract. <pre>          __3___8_____	<br>        \\/ 55,742,968.	<br>          -27		<br>          ----		<br>      3484) 28742	<br>           -27872	<br>           ------	<br>              870	<br> </pre> We are ready to start over on the next digit.  Bring down the next three digits.  The divisor starts as 3 times the square of the number on top ($3 \\times 38<sup>2</sup>=4332$) leaving room for two more digits (4332__). <pre>          __3___8_____	<br>        \\/ 55,742,968.	<br>          -27		<br>          ----		<br>      3484) 28742	<br>           -27872	<br>           ------	<br>     4332__ ) 870968	<br> </pre> It looks like 2 is the next digit. <pre>          __3___8___2_	<br>        \\/ 55,742,968.	<br>          -27		<br>          ----		<br>      3484) 28742	<br>           -27872	<br>           ------	<br>     4332__ ) 870968	<br> </pre> Add 3 times the previous number on top (38) times the last digit (2) times 10 ($3 \\times 38 \\times 2 = 228 \\times 10 = 2280$) and the square of the last digit ($2<sup>2</sup> = 4$). <pre>      433200	<br>        2280	<br>     +     4	<br>     -------	<br>      435484	<br> </pre> Our new divisor is 435484. <pre>          __3___8___2_	<br>        \\/ 55,742,968.	<br>          -27		<br>          ----		<br>      3484) 28742	<br>           -27872	<br>           ------	<br>     435484 ) 870968	<br> </pre> Now multiply by the last digit ($2 \\times 435484 = 870968$) and subtract. <pre>          __3___8___2_	<br>        \\/ 55,742,968.	<br>          -27		<br>          ----		<br>      3484) 28742	<br>           -27872	<br>           ------	<br>     435484 ) 870968	<br>             -870968	<br>             -------	<br>                   0	<br> </pre> </p> <p> So the cube root of 55742968 is 382.  You can continue for as many decimal places as you need: just bring down more triples of zeros. </p> <p> <strong>Why does this work?</strong> </p> <p> Consider $(10A + B)<sup>3</sup> = 1000A<sup>3</sup> + 3 \\times 100A<sup>2</sup>B + 3 \\times 10AB<sup>2</sup> + B<sup>3</sup>$ and think about finding the volume of a cube. </p> <p> The volume of the three thin plates is $3 \\times 100A<sup>2</sup>B$. The volume of the three skinny sticks is $3 \\times 10AB<sup>2</sup>$. The tiny cube is $B<sup>3</sup>$. If we know A and the volume of the cube, S, what B should we choose?   </p> <p> We previously subtracted $A<sup>3</sup>$ from S.  To scale to $1000A<sup>3</sup>$, we bring down three more digits  (a factor of 1000) of the length of S.  We write down 3 times A squared ($3A<sup>2</sup>$), but shifted two places ($100 \\times 3A<sup>2</sup>$ or  $3 \\times 100A<sup>2</sup>$).  We estimate B.  We add 30 times A times B ($30 \\times AB$ or $3 \\times 10AB$) and B squared. Multiplying that by B gives us  $3 \\times 100A<sup>2</sup>B + 3 \\times 10AB<sup>2</sup> + B<sup>3</sup>$. When we subtract that from the remainder (remember we already subtracted $A<sup>3</sup>$), we have subtracted exactly $(10A + B)<sup>3</sup>$.  That is, we have improved our knowledge of the square root by one digit, B. </p> <p> We take whatever remains, scale again by 1000, by bringing down three more digits, and repeat the process. </p>";
	rdfs:label "cube root".

:CubeRootImplementation1 a :Program;
	:implements :CubeRoot;
	:implementationLanguage "C";
	:implementationURL <http://gams.nist.gov/serve.cgi/Class/C2/>.

:CubeRootImplementation2 a :Program;
	:implements :CubeRoot;
	:implementationLanguage "Fortran";
	:implementationURL <http://gams.nist.gov/serve.cgi/Class/C2/>.

:CuckooHashing			a :DataStructure;
	rdfs:comment "A dictionary implemented with two hash tables, $T<sub>1</sub>$ and $T<sub>2</sub>$, and two different  hash functions, $h<sub>1</sub>$ and $h<sub>2</sub>$.  Each key, $k$, is either in $T<sub>1</sub>[h<sub>1</sub>(k)]$ or $T<sub>2</sub>[h<sub>2</sub>(k)]$.  A new key, $k$, is stored in $T<sub>1</sub>[h<sub>1</sub>(k)]$.  If that location is already occupied by another key, $l$, the other key is moved to $T<sub>2</sub>[h<sub>2</sub>(l)]$.  Key are moved back and forth until a key moves to an empty location or a limit is reached. If the limit is reached, new hash functions are chosen, and the tables are rehashed.  For tables that are a bit less than half full and universal hashing functions, performance is good.  A key is deleted by removing it from a table.";
	rdfs:subClassOf :HashTable;
	:aggregateChild :Array;
	:aggregateChild :HashFunction;
	rdfs:label "cuckoo hashing".

:CyclicRedundancyCheck		a :Algorithm;
	rdfs:comment "(1) A method to detect and correct errors by adding bits derived from a block or string of bits to the block. (2) An algorithm to compute bits characteristic of a block based on the algebra of polynomials over the integers, modulo 2. (3) The characteristic bits of a block.";
	rdfs:label "cyclic redundancy check".

:DAGShortestPaths		a :Algorithm;
	rdfs:comment "Solve the single-source shortest-path problem in a weighted directed acyclic graph by 1) doing a topological sort on the vertices by edge so vertices with no incoming edges are first and vertices with only incoming edges are last, 2) assign an infinite distance to every vertex ($dist(v)=\\infty$) and a zero distance to the source, and 3) for each vertex $v$ in sorted order, for each outgoing edge $e(v,u)$, if $dist(v) + weight(e) &lt; dist(u)$, set $dist(u)=dist(v) + weight(e)$ and the predecessor of $u$ to $v$.";
	rdfs:label "DAG shortest paths".

:DepthFirstSearch		a :Algorithm;
	rdfs:comment "(1) Any search algorithm that considers outgoing edges of a vertex before any neighbors of the vertex, that is, outgoing edges of the vertex's predecessor in the search.  Extremes are searched first.  This is easily implemented with recursion.  (2) An algorithm that marks all vertices in a directed graph in the order they are discovered and finished, partitioning the graph into a forest.";
	rdfs:label "depth-first search".

:DepthFirstSearchImplementation1 a :Program;
	:implements :DepthFirstSearch;
	:implementationLanguage "Lisp";
	:implementationURL <http://yoda.cis.temple.edu:8080/UGAIWWW/books/knight/dfs.html>.

:DepthFirstSearchImplementation2 a :Program;
	:implements :DepthFirstSearch;
	:implementationLanguage "Prolog";
	:implementationURL <http://yoda.cis.temple.edu:8080/UGAIWWW/books/shoham/chapter2/section2.4.html>.

:Deque				a :DataStructure;
	rdfs:comment "A data structure in which items may be added to or deleted from the head or the tail.";
	rdfs:label "deque".

:Derangement			a :Algorithm;
	rdfs:comment "A permutation of elements, where no element is in its original position.";
	rdfs:subClassOf :Permutation;
	rdfs:label "derangement".

:DeterministicAlgorithm		a :AlgorithmicTechnique;
	rdfs:comment "An algorithm whose behavior can be completely predicted from the input.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "deterministic algorithm".

:DeterministicFiniteAutomataStringSearch	a :Algorithm;
	rdfs:comment "A string matching algorithm which builds a deterministic finite state machine to recognize the search string.  The machine is then run at each location in turn.  If the machine accepts, that is a match.";
	rdfs:subClassOf :StringMatching;
	rdfs:label "deterministic finite automata string search".

:DeterministicFiniteAutomataStringSearchImplementation1 a :Program;
	:implements :DeterministicFiniteAutomataStringSearch;
	:implementationLanguage "C";
	:implementationURL <http://www-igm.univ-mlv.fr/~lecroq/string/node4.html>.

:DeterministicFiniteAutomataStringSearchImplementation2 a :Program;
	:implements :DeterministicFiniteAutomataStringSearch;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/716.srch.c>.

:DeutschJozsaAlgorithm		a :Algorithm;
	rdfs:comment "A quantum algorithm to determine whether a function is constant or balanced, that is, returns 1 for half the domain and 0 for the other half.  For a function taking $n$ input qubits, first, do Hadamards on $n$ 0's, forming all possible inputs, and a single 1, which will be the answer qubit. Next, run the function once; this exclusive or's the result with the answer qubit.  Finally, do Hadamards on the $n$ inputs again, and measure the answer qubit.  If it is 0, the function is constant, otherwise the function is balanced.";
	rdfs:label "Deutsch-Jozsa algorithm".

:Dictionary			a :AbstractDataType;
	rdfs:comment "An abstract data type storing items, or values.  A value is accessed by an associated key. Basic operations are new, insert, find and delete.";
	rdfs:subClassOf :BinaryRelation;
	rdfs:subClassOf :AbstractDataType;
	rdfs:label "dictionary".

:DictionaryImplementation1 a :Program;
	:implements :Dictionary;
	:implementationLanguage "C++";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/dictionaries.shtml>.

:DictionaryImplementation2 a :Program;
	:implements :Dictionary;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/dictionaries.shtml>.

:DictionaryImplementation3 a :Program;
	:implements :Dictionary;
	:implementationLanguage "Fortran";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/dictionaries.shtml>.

:DictionaryImplementation4 a :Program;
	:implements :Dictionary;
	:implementationLanguage "C";
	:implementationURL <http://users.footprints.net/~kaz/kazlib.html>.

:DigitalSearchTree		a :DataStructure;
	rdfs:comment "A trie which stores the strings in internal nodes, so there is no need for extra leaf nodes to store the strings.";
	rdfs:subClassOf :Trie;
	rdfs:label "digital search tree".

:DigitalTree			a :DataStructure;
	rdfs:comment "A tree for storing strings in which nodes are organized by substrings common to two or more strings.";
	rdfs:subClassOf :Tree;
	rdfs:label "digital tree".

:DijkstrasAlgorithm		a :Algorithm;
	rdfs:comment "An algorithm to find the shortest paths from a single source vertex to all other vertices in a weighted, directed graph.  All weights must be nonnegative. Implementing the priority queue with a Fibonacci heap makes the time complexity $O(E + V \\log V)$, where $V$ is the number of vertices and $E$ is the number of edges.";
	:aggregateChild :PriorityQueue;
	:aggregateChild :FibonacciHeap;
	rdfs:label "Dijkstra's algorithm".

:DijkstrasAlgorithmImplementation1 a :Program;
	:implements :DijkstrasAlgorithm;
	:implementationLanguage "C";
	:implementationURL <http://ciips.ee.uwa.edu.au/~morris/Year2/PLDS210/dijkstra.html>.

:DiminishingIncrementSort	a :Algorithm;
	rdfs:comment "An in-place sort algorithm that repeatedly reorders different, small subsets of the input until the entire array is ordered. On each pass it handles $i$ sets of $n/i$ items, where $n$ is the total number of items.  Each set is every $i<sup>th</sup>$ item, e.g. set 1 is item 1, 1+i, 1+2i, etc., set 2 is item 2, 2+i, etc.  On each succeeding pass, the increment or gap, $i$, is reduced until it is 1 for the last pass.";
	rdfs:subClassOf :InPlaceSort;
	rdfs:label "diminishing increment sort".

:DirectChaining			a :DataStructure;
	rdfs:comment "A collision resolution scheme in which the hash table is an array of links to lists. Each list holds all the items with the same hash value.";
	rdfs:subClassOf :SeparateChaining;
	rdfs:label "direct chaining".

:DirectChainingImplementation1 a :Program;
	:implements :DirectChaining;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3310.ins.c>.

:DirectChainingImplementation2 a :Program;
	:implements :DirectChaining;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3310.srch.c>.

:DirectChainingImplementation3 a :Program;
	:implements :DirectChaining;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.williams.edu/~bailey/JavaStructures/bailey/structure/ChainedHashtable.java>.

:DirectedAcyclicWordGraph	a :DataStructure;
	rdfs:comment "(1) A directed acyclic graph representing the suffixes of a given string in which each edge is labeled with a character.  The characters along a path from the root to a node are the substring which the node represents. (2) A finite state machine that recognizes a set of words.";
	rdfs:label "directed acyclic word graph".

:DirectedGraph			a :DataStructure;
	rdfs:comment "A graph whose edges are <em>ordered</em> pairs of  vertices.  That is, each edge can be followed from one vertex to another vertex.";
	rdfs:subClassOf :Graph;
	:aggregateChild :Source;
	:aggregateChild :Sink;
	:aggregateChild :InDegree;
	:aggregateChild :OutDegree;
	rdfs:label "directed graph".

:DirectedGraphImplementation1 a :Program;
	:implements :DirectedGraph;
	:implementationLanguage "Java";
	:implementationURL <http://www.helsinki.fi/~jbrown/tira/overview.html>.

:DiscreteIntervalEncodingTree	a :DataStructure;
	rdfs:comment "A binary search tree that stores consecutive values as intervals.";
	rdfs:subClassOf :BinarySearchTree;
	rdfs:label "discrete interval encoding tree".

:DiscreteIntervalEncodingTreeImplementation1 a :Program;
	:implements :DiscreteIntervalEncodingTree;
	:implementationLanguage "ML";
	:implementationURL <http://web.engr.oregonstate.edu/~erwig/diet/diet.sml.txt>.

:DiscreteIntervalEncodingTreeImplementation2 a :Program;
	:implements :DiscreteIntervalEncodingTree;
	:implementationLanguage "Haskell";
	:implementationURL <http://web.engr.oregonstate.edu/~erwig/diet/diet.hs.txt>.

:DistributionSort		a :Algorithm;
	rdfs:comment "Any sort algorithm where data is distributed from its input to multiple intermediate structures  which are then gathered and placed on the output.";
	rdfs:label "distribution sort".

:DivideAndConquer		a :AlgorithmicTechnique;
	rdfs:comment "Solve a problem, either directly because solving that instance is easy (typically, because the instance is small) or by <em>dividing</em> it into two or more smaller instances.  Each of these smaller instances is  recursively solved, and the solutions are combined to produce a solution for the original instance.";
	rdfs:label "divide and conquer".

:DivideAndMarriageBeforeConquest	a :AlgorithmicTechnique;
	rdfs:comment "A variant of divide and conquer in which subproblems created in the ``divide'' step are merged before the ``conquer'' step.";
	rdfs:label "divide and marriage before conquest".

:DoomsdayRule			a :Algorithm;
	rdfs:comment "An algorithm to find the day of the week for any date.  It is simple enough to memorize and do mentally.";
	rdfs:label "Doomsday rule".

:DoubleEndedPriorityQueue	a :DataStructure;
	rdfs:comment "A priority queue which simultaneously keeps track of the maximum and minimum keys, and supports operations efficiently on either extreme (minimum or maximum).";
	rdfs:subClassOf :PriorityQueue;
	rdfs:label "double-ended priority queue".

:DoubleHashing			a :Algorithm;
	rdfs:comment "A method of open addressing for a hash table in which a collision is resolved by searching the table for an empty place at intervals given by a different hash function, thus minimizing clustering.";
	rdfs:label "double hashing".

:DoubleHashingImplementation1 a :Program;
	:implements :DoubleHashing;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/335.ins.c>.

:DoubleHashingImplementation2 a :Program;
	:implements :DoubleHashing;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/335.ins.c>.

:DoubleHashingImplementation3 a :Program;
	:implements :DoubleHashing;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/335.srch.c>.

:DoubleHashingImplementation4 a :Program;
	:implements :DoubleHashing;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/335.srch.c>.

:DoubleMetaphone		a :Algorithm;
	rdfs:comment "An algorithm to code English words (and foreign words often heard in the United States) phonetically by reducing them to 12 consonant sounds.  This reduces matching problems from wrong spelling.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "double metaphone".

:DoubleMetaphoneImplementation1 a :Program;
	:implements :DoubleMetaphone;
	:implementationLanguage "Basic";
	:implementationURL <http://aspell.sourceforge.net/metaphone/>.

:DoubleMetaphoneImplementation2 a :Program;
	:implements :DoubleMetaphone;
	:implementationLanguage "C";
	:implementationURL <http://aspell.sourceforge.net/metaphone/>.

:DoubleMetaphoneImplementation3 a :Program;
	:implements :DoubleMetaphone;
	:implementationLanguage "Perl";
	:implementationURL <http://aspell.sourceforge.net/metaphone/>.

:DoubleMetaphoneImplementation4 a :Program;
	:implements :DoubleMetaphone;
	:implementationLanguage "C++";
	:implementationURL <http://aspell.sourceforge.net/metaphone/>.

:DoubleMetaphoneImplementation5 a :Program;
	:implements :DoubleMetaphone;
	:implementationLanguage "Java";
	:implementationURL <http://jakarta.apache.org/commons/codec/>.

:DoubleMetaphoneImplementation6 a :Program;
	:implements :DoubleMetaphone;
	:implementationLanguage "Java";
	:implementationURL <http://www.wbrogden.com/phonetic/index.html>.

:DoubleMetaphoneImplementation7 a :Program;
	:implements :DoubleMetaphone;
	:implementationLanguage "C++";
	:implementationURL <ftp://ftp.cuj.com/pub/2000/1806/philips.zip>.

:DoublyLinkedList		a :DataStructure;
	rdfs:comment "A variant of a linked list in which each item has a link to the previous item as well as the next.  This allows easily accessing list items backward as well as forward and deleting any item in constant time.";
	rdfs:label "doubly linked list".

:DoublyLinkedListImplementation1 a :Program;
	:implements :DoublyLinkedList;
	:implementationLanguage "C";
	:implementationURL <http://users.footprints.net/~kaz/kazlib.html>.

:DutchNationalFlag		a :Algorithm;
	rdfs:comment "Rearrange elements in an array into three groups: bottom, middle, and top.  During execution, the top group grows down from the top of the array, the bottom group grows up from the bottom, and the middle group is kept just above the bottom.  The algorithm stores the locations just below the top group, just above the bottom, and just above the middle in three indexes.  At each step, examine the element just above the middle. If it belongs to the top group, swap it with the element just below the top.  If it belongs in the bottom, swap it with the element just above the bottom.  If it is in the middle, leave it.  Update the appropriate index. Complexity is O(n) moves and examinations.";
	rdfs:label "Dutch national flag".

:DynamicArray			a :DataStructure;
	rdfs:comment "An array whose size may change over time.  Items are not only added or removed, but memory used changes, too.";
	rdfs:subClassOf :Array;
	rdfs:label "dynamic array".

:DynamicHashing			a :DataStructure;
	rdfs:comment "A hash table that grows to handle more items.  The associated hash function must change as the table grows.  Some schemes may shrink the table to save space when items are deleted.";
	rdfs:subClassOf :HashTable;
	:aggregateChild :LoadFactor;
	rdfs:label "dynamic hashing".

:DynamicHashingImplementation1 a :Program;
	:implements :DynamicHashing;
	:implementationLanguage "C";
	:implementationURL <http://cbfalconer.home.att.net/download/>.

:DynamicHashingImplementation2 a :Program;
	:implements :DynamicHashing;
	:implementationLanguage "C";
	:implementationURL <http://users.footprints.net/~kaz/kazlib.html>.

:DynamicProgramming		a :AlgorithmicTechnique;
	rdfs:comment "Solve an optimization problem by caching subproblem solutions (memoization) rather than recomputing them.";
	rdfs:label "dynamic programming".

:DynamizationTransformation	a :AlgorithmicTechnique;
	rdfs:comment "A data structuring technique that can make a static data structure dynamic.  In so doing, the performance of the dynamic structure will exhibit certain space-time tradeoffs.";
	rdfs:label "dynamization transformation".

:ElasticBucketTrie		a :DataStructure;
	rdfs:comment "A variant of a bucket trie in which each leaf node for $n$ strings is a bucket allocated to hold exactly $n$ strings.";
	rdfs:subClassOf :BucketTrie;
	rdfs:label "elastic-bucket trie".

:EuclidsAlgorithm		a :Algorithm;
	rdfs:comment "An algorithm to compute the greatest common divisor of two positive integers.  It is <tt>Euclid(a,b){if (b=0) then return a; else return Euclid(b, a mod b);}</tt>.  The run time complexity is  $O((\\log a)(\\log b))$ bit operations. ";
	rdfs:label "Euclid's algorithm".

:EuclidsAlgorithmImplementation1 a :Program;
	:implements :EuclidsAlgorithm;
	:implementationLanguage "WOOP/ADA";
	:implementationURL <http://www.auto.tuwien.ac.at/~blieb/woop/euclid.html>.

:EuclidsAlgorithmImplementation2 a :Program;
	:implements :EuclidsAlgorithm;
	:implementationLanguage "Scheme";
	:implementationURL <http://www.math.grin.edu/~stone/events/scheme-workshop/gcd.html>.

:EXCELL				a :DataStructure;
	rdfs:comment "A point access method using a dynamic multidimensional array.";
	rdfs:subClassOf :PointAccessMethod;
	rdfs:label "EXCELL".

:ExhaustiveSearch		a :AlgorithmicTechnique;
	rdfs:comment "An algorithm that finds a solution by trying every possibility.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "exhaustive search".

:ExtendedBinaryTree		a :DataStructure;
	rdfs:comment "A binary tree with special nodes replacing every null subtree.  Every regular node has two children, and every special node has no children.";
	rdfs:subClassOf :BinaryTree;
	rdfs:label "extended binary tree".

:ExtendedEuclidsAlgorithm	a :Algorithm;
	rdfs:comment "An algorithm to find the greatest common divisor, <em>g</em>, of two positive integers, <em>a</em> and <em>b</em>, and coefficients, <em>h</em> and <em>j</em>, such that <em>g = ha + jb</em>.";
	rdfs:label "extended Euclid's algorithm".

:ExtendedKDTree			a :DataStructure;
	rdfs:comment "A spatial access method where successive levels are split along different dimensions into nonoverlapping cells.  Objects are indexed in all cells they intersect.";
	rdfs:subClassOf :SpatialAccessMethod;
	rdfs:label "extended k-d tree".

:ExtendibleHashing		a :DataStructure;
	rdfs:comment "A hash table in which the hash function is the last few bits of the key and the table refers to buckets.  Table entries with the same final bits may use the same bucket.  If a bucket overflows, it splits, and if only one entry referred to it, the table doubles in size.  If a bucket is emptied by deletion, entries using it are changed to refer to an adjoining bucket, and the table may be halved.";
	rdfs:subClassOf :DynamicHashing;
	rdfs:label "extendible hashing".

:ExtendibleHashingImplementation1 a :Program;
	:implements :ExtendibleHashing;
	:implementationLanguage "COBOL";
	:implementationURL <http://www.istis.unomaha.edu/isqa/haworth/isqa3300/fs009.htm>.

:ExternalIndex			a :DataStructure;
	rdfs:comment "An auxiliary data structure added to a main data structure to improve operations, such as a search on a secondary key.";
	rdfs:label "external index".

:ExternalMemoryAlgorithm	a :Algorithm;
	rdfs:comment "An algorithm that is efficient when accessing most of the data is very slow, such as, on disk.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "external memory algorithm".

:ExternalMemoryDataStructure	a :DataStructure;
	rdfs:comment "A data structure that is efficient even when accessing most of the data is very slow, such as, on a disk.";
	rdfs:subClassOf :DataStructure;
	rdfs:label "external memory data structure".

:ExternalMerge			a :Algorithm;
	rdfs:comment "To combine multiple sorted data streams into a single sorted stream using external storage.";
	rdfs:label "external merge".

:ExternalQuicksort		a :Algorithm;
	rdfs:comment "Read the $M/2$ first and last elements into a buffer (the buffer acts like the pivot in quicksort), and sort them.  Read the next element from the beginning or end to balance writing.  If the next element is less than the least of the buffer, write it to available space at the beginning.  If greater than the greatest, write it to the end.  Otherwise write the greatest or least of the buffer, and put the next element in the buffer.  Keep the maximum lower and minimum upper keys written to avoid resorting middle elements that are in order.   When done, write the buffer.  Recursively sort the smaller partition, and loop to sort the remaining partition.";
	rdfs:subClassOf :ExternalSort;
	rdfs:subClassOf :InPlaceSort;
	:aggregateChild :Partition;
	rdfs:label "external quicksort".

:ExternalQuicksortImplementation1 a :Program;
	:implements :ExternalQuicksort;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/446.sort.c>.

:FastFourierTransform		a :Algorithm;
	rdfs:comment "An algorithm to convert a set of uniformly spaced points from the time domain to the frequency domain.";
	rdfs:label "fast fourier transform".

:FastFourierTransformImplementation1 a :Program;
	:implements :FastFourierTransform;
	:implementationLanguage "WOOP/ADA";
	:implementationURL <http://www.auto.tuwien.ac.at/~blieb/woop/fft.html>.

:Fathoming			a :AlgorithmicTechnique;
	rdfs:comment "Pruning a search tree.";
	rdfs:label "fathoming".

:FibonaccianSearch		a :Algorithm;
	rdfs:comment "Search a sorted array by narrowing possible locations to progressively smaller intervals.  Begin with two Fibonacci numbers, p (F(n)) and q (F(n+1)), such that $p &lt; n \\leq q$, where $n$ is the size of the array.  The first step checks location p.  The size of the next interval is p, if the key is less than the item at that location, or q-p (F(n-1)) if it is greater.";
	:aggregateChild :FibonacciNumber;
	:aggregateChild :FibonacciTree;
	rdfs:label "Fibonaccian search".

:FibonaccianSearchImplementation1 a :Program;
	:implements :FibonaccianSearch;
	:implementationLanguage "WOOP/ADA";
	:implementationURL <http://www.auto.tuwien.ac.at/~blieb/woop/fibsearc.html>.

:FibonacciHeap			a :DataStructure;
	rdfs:comment "A heap made of a forest of trees.  The amortized cost of the operations create, insert a value, decrease a value, find minimum, and merge or join (meld) two heaps, is a constant $\\Theta(1)$.  The delete operation takes $O(\\log n)$.";
	rdfs:subClassOf :Heap;
	rdfs:label "Fibonacci heap".

:FibonacciHeapImplementation1 a :Program;
	:implements :FibonacciHeap;
	:implementationLanguage "C++";
	:implementationURL <http://algorithm.myrice.com/resources/technical_artile/fibonacci_heap/fibonacci.htm>.

:FibonacciTree			a :DataStructure;
	rdfs:comment "A variant of a binary tree where a tree of order $n$ ($n>1$) has a left subtree of order $n-1$ and a right subtree of order $n-2$.  An order 0 Fibonacci tree has no nodes, and an order 1 tree has 1 node.";
	rdfs:subClassOf :BinaryTree;
	rdfs:subClassOf :AVLTree;
	:aggregateChild :FibonacciNumber;
	rdfs:label "Fibonacci tree".

:Find				a :Algorithm;
	rdfs:comment "An algorithm to select the k<sup>th</sup> smallest element of an array and partition the array around it.  First, partition around the value of the k<sup>th</sup> element.  If the split is not at element k, move the upper or lower boundary and partition again.";
	rdfs:label "Find".

:FindImplementation1 a :Program;
	:implements :Find;
	:implementationLanguage "Rexx";
	:implementationURL <http://www.geocities.com/SiliconValley/Garage/3323/3alg.html>.

:FinitaryTree			a :DataStructure;
	rdfs:comment "A tree with a finite number of children at every node.";
	rdfs:subClassOf :Tree;
	rdfs:label "finitary tree".

:FisherYatesShuffle		a :Algorithm;
	rdfs:comment "Randomly permute $N$ elements by exchanging each element $e<sub>i</sub>$ with a random element from $i$ to $N$. It consumes $\\Theta(N \\log N)$ bits and runs in linear time.";
	rdfs:subClassOf :PerfectShuffle;
	rdfs:subClassOf :Permutation;
	rdfs:label "Fisher-Yates shuffle".

:FisherYatesShuffleImplementation1 a :Program;
	:implements :FisherYatesShuffle;
	:implementationLanguage "C";
	:implementationURL <http://www.stanford.edu/~blp/writings/clc/shuffle.html>.

:FloydWarshallAlgorithm		a :Algorithm;
	rdfs:comment "An algorithm to solve the all pairs shortest path problem in a weighted, directed graph by multiplying an adjacency-matrix representation of the graph multiple times.  The edges may have negative weights, but no negative weight cycles. The time complexity is $\\Theta (V<sup>3</sup>)$.";
	rdfs:label "Floyd-Warshall algorithm".

:FordFulkersonMethod		a :Algorithm;
	rdfs:comment "Given a flow function and its corresponding residual graph (a maximum-flow problem), select a path from the source to the sink along which the flow can be increased and increase the flow. Repeat until there are no such paths.";
	rdfs:label "Ford-Fulkerson method".

:ForwardIndex			a :DataStructure;
	rdfs:comment "An index into a set of texts.  This is usually created as the first step to making an inverted index.";
	rdfs:label "forward index".

:FrequencyCountHeuristic	a :Algorithm;
	rdfs:comment "A heuristic that keeps the elements of a list ordered by number of times each element is the target of a search.";
	rdfs:subClassOf :Heuristic;
	rdfs:label "frequency count heuristic".

:FullBinaryTree			a :DataStructure;
	rdfs:comment "A binary tree in which each node has exactly zero or two children.";
	rdfs:subClassOf :BinaryTree;
	rdfs:label "full binary tree".

:FullInvertedIndex		a :DataStructure;
	rdfs:comment "An inverted index which includes the exact location within texts, in addition to the text in which the word appears.";
	rdfs:subClassOf :InvertedIndex;
	rdfs:label "full inverted index".

:FullyPolynomialApproximationScheme	a :AlgorithmicTechnique;
	rdfs:comment "A set of algorithms ${A<sub>\\epsilon</sub> | \\epsilon &gt; 0\\}$,  where each $A<sub>\\epsilon</sub>$ is a $1+\\epsilon$-approximation algorithm bounded by a polynomial in the length of the input and $1/\\epsilon$. ";
	rdfs:label "fully polynomial approximation scheme".

:GBDTree			a :DataStructure;
	rdfs:comment "A generalized BD-tree, hence the name, which stores spatially extended objects as a hierarchy  of minimum bounding boxes.  It is a balanced multiway tree which serves as a spatial access method.";
	rdfs:subClassOf :BDTree;
	rdfs:label "GBD-tree".

:GnomeSort			a :Algorithm;
	rdfs:comment "Put items in order by comparing the current item with the previous item.  If they are in order, move to the next item (or stop if the end is reached).  If they are out of order, swap them and move to the previous item.  If there is no previous item, move to the next item.";
	rdfs:subClassOf :Sort;
	rdfs:subClassOf :InPlaceSort;
	rdfs:label "gnome sort".

:GnomeSortImplementation1 a :Program;
	:implements :GnomeSort;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.vu.nl/~dick/gnomesort.html>.

:Graph				a :DataStructure;
	rdfs:comment "A set of items connected by edges.  Each item is called a vertex or node.  Formally, a graph is a set of vertices and a binary relation between vertices, adjacency.";
	:aggregateChild :Vertex;
	:aggregateChild :Edge;
	rdfs:label "graph".

:GraphImplementation1 a :Program;
	:implements :Graph;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/implement/graphed/implement.shtml>.

:GraphImplementation2 a :Program;
	:implements :Graph;
	:implementationLanguage "C++";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/graph-data-structures.shtml>.

:GraphImplementation3 a :Program;
	:implements :Graph;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/graph-data-structures.shtml>.

:GraphImplementation4 a :Program;
	:implements :Graph;
	:implementationLanguage "Mathematica";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/graph-data-structures.shtml>.

:GraphImplementation5 a :Program;
	:implements :Graph;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/graph-data-structures.shtml>.

:GraphImplementation6 a :Program;
	:implements :Graph;
	:implementationLanguage "Java";
	:implementationURL <http://www.helsinki.fi/~jbrown/tira/overview.html>.

:GraphImplementation7 a :Program;
	:implements :Graph;
	:implementationLanguage "Java";
	:implementationURL <http://jgrapht.sourceforge.net/>.

:GraphImplementation8 a :Program;
	:implements :Graph;
	:implementationLanguage "Java";
	:implementationURL <http://gef.tigris.org/>.

:GraphImplementation9 a :Program;
	:implements :Graph;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/generating-graphs.shtml>.

:GraphImplementation10 a :Program;
	:implements :Graph;
	:implementationLanguage "Mathematica";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/generating-graphs.shtml>.

:GraphImplementation11 a :Program;
	:implements :Graph;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/generating-graphs.shtml>.

:GraphImplementation12 a :Program;
	:implements :Graph;
	:implementationLanguage "C++";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/generating-graphs.shtml>.

:GraphImplementation13 a :Program;
	:implements :Graph;
	:implementationLanguage "Fortran";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/generating-graphs.shtml>.

:GraphImplementation14 a :Program;
	:implements :Graph;
	:implementationLanguage "C";
	:implementationURL <http://infosun.fmi.uni-passau.de/GTL/>.

:GraphImplementation15 a :Program;
	:implements :Graph;
	:implementationLanguage "C++";
	:implementationURL <http://www.boost.org/libs/graph/doc/>.

:GraphImplementation16 a :Program;
	:implements :Graph;
	:implementationLanguage "Java";
	:implementationURL <http://www.jdsl.org/home.html>.

:GreatestCommonDivisor		a :Algorithm;
	rdfs:comment "(1) The greatest integer which is a divisor of given positive integers.  For instance, GCD(30, 42) = 6.  (2) An algorithm to find the same.";
	rdfs:label "greatest common divisor".

:GreatestCommonDivisorImplementation1 a :Program;
	:implements :GreatestCommonDivisor;
	:implementationLanguage "Scheme";
	:implementationURL <http://www.math.grin.edu/~stone/events/scheme-workshop/gcd.html>.

:GreedyAlgorithm		a :AlgorithmicTechnique;
	rdfs:comment "An algorithm that always takes the best immediate, or local, solution while finding an answer.  Greedy algorithms find the overall, or globally, optimal solution for some optimization problems, but may find less-than-optimal solutions for some instances of other problems.";
	rdfs:label "greedy algorithm".

:GreedyHeuristic		a :AlgorithmicTechnique;
	rdfs:comment "Solve an optimization problem by finding locally optimal solutions.";
	rdfs:label "greedy heuristic".

:GridFile			a :DataStructure;
	rdfs:comment "A point access method which splits space into a nonperiodic grid.  Each spatial dimension is divided by a linear hash.  Small sets of points are referred to by one or more cells of the grid.";
	rdfs:subClassOf :PointAccessMethod;
	rdfs:label "grid file".

:HashFunction			a :Algorithm;
	rdfs:comment "A function that maps keys to integers, usually to get an even distribution on a smaller set of values.";
	rdfs:label "hash function".

:HashFunctionImplementation1 a :Program;
	:implements :HashFunction;
	:implementationLanguage "C++";
	:implementationURL <http://www.nist.gov/dads/HTML/minimalPerfectHash.html>.

:HashFunctionImplementation2 a :Program;
	:implements :HashFunction;
	:implementationLanguage "C";
	:implementationURL <http://www.nist.gov/dads/HTML/minimalPerfectHash.html>.

:HashFunctionImplementation3 a :Program;
	:implements :HashFunction;
	:implementationLanguage "C";
	:implementationURL <http://burtleburtle.net/bob/hash/doobs.html>.

:HashFunctionImplementation4 a :Program;
	:implements :HashFunction;
	:implementationLanguage "C";
	:implementationURL <http://www.concentric.net/~Ttwang/tech/inthash.htm>.

:HashFunctionImplementation5 a :Program;
	:implements :HashFunction;
	:implementationLanguage "C";
	:implementationURL <http://www.isthe.com/chongo/tech/comp/fnv/>.

:HashFunctionImplementation6 a :Program;
	:implements :HashFunction;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/331.hash.c>.

:HashFunctionImplementation7 a :Program;
	:implements :HashFunction;
	:implementationLanguage "C";
	:implementationURL <http://users.footprints.net/~kaz/kazlib.html>.

:HashHeap			a :DataStructure;
	rdfs:comment "An efficient implementation of a priority queue.  The  linear hash function monotonically maps keys to buckets, and each bucket is a heap.";
	rdfs:label "hash heap".

:HashTable			a :DataStructure;
	rdfs:comment "A dictionary in which keys are mapped to  array positions by hash functions.  Having the keys of more than one item map to the same position is called a collision. There are many collision resolution schemes, but they may be divided into open addressing, chaining, and keeping one special overflow area. Perfect hashing avoids collisions, but may be time-consuming to create.";
	rdfs:subClassOf :Dictionary;
	:aggregateChild :LoadFactor;
	:aggregateChild :HashTableDelete;
	:aggregateChild :CoalescedChaining;
	:aggregateChild :LinearProbing;
	:aggregateChild :DoubleHashing;
	:aggregateChild :QuadraticProbing;
	:aggregateChild :UniformHashing;
	:aggregateChild :SimpleUniformHashing;
	:aggregateChild :SeparateChaining;
	:aggregateChild :DirectChaining;
	:aggregateChild :Clustering;
	rdfs:label "hash table".

:HashTableImplementation1 a :Program;
	:implements :HashTable;
	:implementationLanguage "C";
	:implementationURL <http://burtleburtle.net/bob/hash/hashtab.html>.

:HashTableImplementation2 a :Program;
	:implements :HashTable;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/334.ins.c>.

:HashTableImplementation3 a :Program;
	:implements :HashTable;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/334.srch.c>.

:HashTableImplementation4 a :Program;
	:implements :HashTable;
	:implementationLanguage "C";
	:implementationURL <http://users.footprints.net/~kaz/kazlib.html>.

:HashTableImplementation5 a :Program;
	:implements :HashTable;
	:implementationLanguage "Visual Basic";
	:implementationURL <http://epaperpress.com/vbhash/>.

:HashTableImplementation6 a :Program;
	:implements :HashTable;
	:implementationLanguage "C";
	:implementationURL <http://www.sparknotes.com/cs/searching/hashtables/section1.html>.

:HashTableDelete		a :Algorithm;
	rdfs:comment "If the hash table uses chaining, use the chaining data structure delete.  If it uses open addressing, mark the item \"deleted\" for future reuse.";
	rdfs:label "hash table delete".

:HBTree				a :DataStructure;
	rdfs:comment "A point access method which uses k-d trees to organize the space, but partitions as excluded intervals, like the BANG file.  Searching is like in a k-d-B-tree.";
	rdfs:subClassOf :PointAccessMethod;
	rdfs:label "hB-tree".

:Heap				a :DataStructure;
	rdfs:comment "A complete tree where every node has a key more extreme (greater or less) than or equal to the key of its parent. Usually understood to be a binary heap.";
	rdfs:subClassOf :CompleteTree;
	:aggregateChild :HeapProperty;
	rdfs:label "heap".

:Heapify			a :Algorithm;
	rdfs:comment "Rearrange a heap to maintain the heap property, that is, the key of the root node is more extreme (greater or less) than or equal to the keys of its children.  If the root node's key is not more extreme, swap it with the most extreme child key, then recursively heapify that child's subtree.  The child subtrees must be heaps to start.";
	rdfs:label "heapify".

:Heapsort			a :Algorithm;
	rdfs:comment "A sort algorithm that builds a heap, then repeatedly extracts the maximum item.  Run time is  O(n log n).";
	rdfs:subClassOf :InPlaceSort;
	:aggregateChild :Heap;
	rdfs:label "heapsort".

:HeapsortImplementation1 a :Program;
	:implements :Heapsort;
	:implementationLanguage "C";
	:implementationURL <http://www.iti.fh-flensburg.de/lang/algorithmen/sortieren/heap/heapen.htm>.

:HeapsortImplementation2 a :Program;
	:implements :Heapsort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.ubc.ca/spider/harrison/Java/HeapSortAlgorithm.java>.

:HeapsortImplementation3 a :Program;
	:implements :Heapsort;
	:implementationLanguage "Java";
	:implementationURL <http://www2.hawaii.edu/~copley/665/HSMain.html>.

:HeapsortImplementation4 a :Program;
	:implements :Heapsort;
	:implementationLanguage "WOOP/ADA";
	:implementationURL <http://www.auto.tuwien.ac.at/~blieb/woop/heapsort.html>.

:HeapsortImplementation5 a :Program;
	:implements :Heapsort;
	:implementationLanguage "Rexx";
	:implementationURL <http://www.markcrocker.com/rexxtipsntricks/rxtt28.2.0472.html>.

:HeightBalancedBinarySearchTree	a :DataStructure;
	rdfs:comment "A height-balanced tree which is also a binary search tree. It supports membership, insert, and delete operations in time logarithmic in the number of nodes in the tree.";
	rdfs:subClassOf :HeightBalancedTree;
	rdfs:subClassOf :BinarySearchTree;
	rdfs:subClassOf :BalancedBinaryTree;
	rdfs:label "height-balanced binary search tree".

:HeightBalancedTree		a :DataStructure;
	rdfs:comment "A tree whose subtrees differ in height by no more than one and the subtrees are height-balanced, too.  An empty tree is height-balanced.";
	rdfs:subClassOf :BalancedTree;
	rdfs:label "height-balanced tree".

:Heuristic			a :AlgorithmicTechnique;
	rdfs:comment "An algorithm that usually, but not always, works or that gives nearly the right answer.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "heuristic".

:HiddenMarkovModel		a :DataStructure;
	rdfs:comment "A variant of a finite state machine having a set of states, Q, an output alphabet, O, transition probabilities, A, output probabilities, B, and initial state probabilities, $\\Pi$.  The current state is not observable.  Instead, each state produces an output with a certain probability (B).  Usually the states, Q, and outputs, O, are understood, so an HMM is said to be a triple,  $(A, B, \\Pi)$.";
	rdfs:subClassOf :FiniteStateMachine;
	rdfs:label "hidden Markov model".

:HistogramSort			a :Algorithm;
	rdfs:comment "An efficient 3-pass refinement of a bucket sort algorithm.   The first pass counts the number of items for each bucket in an auxiliary array, and then makes a running total so each auxiliary entry is the number of preceding items.  The second pass puts each item in its proper bucket according to the auxiliary entry for the key of that item.  The last pass sorts each bucket.";
	rdfs:subClassOf :BucketSort;
	rdfs:label "histogram sort".

:HistogramSortImplementation1 a :Program;
	:implements :HistogramSort;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/416.sort.c>.

:HistogramSortImplementation2 a :Program;
	:implements :HistogramSort;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/416.sort.c>.

:HornersRule			a :Algorithm;
	rdfs:comment "A polynomial $A(x) = a<sub>0</sub> + a<sub>1</sub>x + a<sub>2</sub>x<sup>2</sup> + a<sub>3</sub>x<sup>3</sup> + \\ldots$ may be written as $A(x) = a<sub>0</sub> + x(a<sub>1</sub> + x(a<sub>2</sub> + x(a<sub>3</sub> + \\ldots)))$.";
	rdfs:label "Horner's rule".

:HuffmanCoding			a :Algorithm;
	rdfs:comment "A minimal variable-length character coding based on the frequency of  each character.  First, each character becomes a trivial  binary tree, with the character as the only node.  The character's frequency is the tree's frequency.  Two trees with the least frequencies are joined as the subtrees of a new root that is assigned the sum of their frequencies.  This is repeated until all characters are in one tree.  One code bit represents each level.  Thus more frequent characters are near the root and are coded with few bits, and rare characters are far from the root and are coded with many bits.";
	:aggregateChild :FullBinaryTree;
	:aggregateChild :PriorityQueue;
	rdfs:label "Huffman coding".

:HuffmanCodingImplementation1 a :Program;
	:implements :HuffmanCoding;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.mu.oz.au/~alistair/abstracts/mk95:wads.html>.

:Hypergraph			a :DataStructure;
	rdfs:comment "A graph whose hyperedges connect two or more  vertices.";
	rdfs:subClassOf :UndirectedGraph;
	:aggregateChild :Hyperedge;
	:aggregateChild :Vertex;
	rdfs:label "hypergraph".

:IdealMerge			a :Algorithm;
	rdfs:comment "Merge $n$ sorted streams into one output stream. To begin the streams are sorted by the value of the head element of each. Then the head of the first stream, which is the least since the streams were sorted, is removed and written to the output.  That stream is inserted back into the list of streams according to its new head.  Taking the head of the first stream and reinserting that stream is repeated until all elements have been processed. Using binary search to find the new place to insert a stream, the execution time is $\\Theta(M \\log N)$ where $M$ is the total number of elements.";
	rdfs:label "ideal merge".

:IndexFile			a :DataStructure;
	rdfs:comment "A file which stores keys and an index into another file.  The index file may have additional structure, e.g., be a B-tree.";
	rdfs:label "index file".

:InOrderTraversal		a :Algorithm;
	rdfs:comment "Process all nodes of a tree by recursively processing the left subtree, then processing the root, and finally the right subtree.";
	rdfs:subClassOf :TreeTraversal;
	rdfs:label "in-order traversal".

:InPlaceSort			a :Algorithm;
	rdfs:comment "A sort algorithm in which the sorted items occupy the same storage as the original ones.  These algorithms may use  o(n) additional memory for bookkeeping, but at most a constant number of items are kept in auxiliary memory at any time.";
	rdfs:subClassOf :Sort;
	rdfs:label "in-place sort".

:InsertionSort			a :Algorithm;
	rdfs:comment "Sort by repeatedly taking the next item and inserting it into the final data structure in its proper order with respect to items already inserted.  Run time is O(n<sup>2</sup>) because of moves.";
	rdfs:subClassOf :Sort;
	rdfs:label "insertion sort".

:InsertionSortImplementation1 a :Program;
	:implements :InsertionSort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.ubc.ca/spider/harrison/Java/InsertionSortAlgorithm.java>.

:InsertionSortImplementation2 a :Program;
	:implements :InsertionSort;
	:implementationLanguage "Scheme";
	:implementationURL <http://www.math.grin.edu/~stone/events/scheme-workshop/insertion.html>.

:InsertionSortImplementation3 a :Program;
	:implements :InsertionSort;
	:implementationLanguage "Fortran";
	:implementationURL <http://gams.nist.gov/serve.cgi/Module/TOMS/505/8547>.

:InterpolationSearch		a :Algorithm;
	rdfs:comment "Search a sorted array by estimating the next position to check based on a linear interpolation of the search key and the values at the ends of the search interval.";
	rdfs:label "interpolation search".

:InterpolationSearchImplementation1 a :Program;
	:implements :InterpolationSearch;
	:implementationLanguage "WOOP/ADA";
	:implementationURL <http://www.auto.tuwien.ac.at/~blieb/woop/fibsearc.html>.

:InterpolationSearchImplementation2 a :Program;
	:implements :InterpolationSearch;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/322.srch.p>.

:InterpolationSequentialSearch	a :Algorithm;
	rdfs:comment "An approximate location is interpolated from the first and last items of a sorted array, then a linear search finds the actual location.";
	rdfs:label "interpolation-sequential search".

:InterpolationSequentialSearchImplementation1 a :Program;
	:implements :InterpolationSequentialSearch;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/323.srch.p>.

:IntrospectiveSort		a :Algorithm;
	rdfs:comment "A variant of quicksort which switches to heapsort for pathological inputs, that is, when execution time is becoming quadratic.";
	rdfs:label "introspective sort".

:InverseAckermannFunction	a :Algorithm;
	rdfs:comment "A function of two parameters whose value grows very, very slowly.";
	rdfs:label "inverse Ackermann function".

:InvertedFileIndex		a :DataStructure;
	rdfs:comment "An inverted index which only indicates the text in which a word appears, not where the word appears within the text.";
	rdfs:subClassOf :InvertedIndex;
	rdfs:label "inverted file index".

:InvertedIndex			a :DataStructure;
	rdfs:comment "An index into a set of texts of the words in the texts. The index is accessed by some search method. Each index entry gives the  word and a list of texts, possibly with locations  within the text, where the word occurs.";
	rdfs:label "inverted index".

:Iteration			a :AlgorithmicTechnique;
	rdfs:comment "Solve a problem by repeatedly working on successive parts of the problem.";
	rdfs:label "iteration".

:JaroWinkler			a :Algorithm;
	rdfs:comment "A measure of similarity between two strings.  The Jaro measure is the weighted sum of percentage of matched characters from each file and transposed characters.  Winkler increased this measure for matching initial characters, then rescaled it by a piecewise function, whose intervals and weights depend on the type of string (first name, last name, street, etc.).";
	rdfs:subClassOf :StringMatchingWithErrors;
	rdfs:label "Jaro-Winkler".

:JohnsonsAlgorithm		a :Algorithm;
	rdfs:comment "An algorithm to solve the all pairs shortest path problem in a sparse weighted, directed graph.  First, it adds a new node with zero weight edges from it to all other nodes, and runs the Bellman-Ford algorithm to check for negative weight cycles and find $h(v)$, the least weight of a path from the new node to node $v$.  Next it reweights the edges using the nodes' $h(v)$ values.  Finally for each node, it runs Dijkstra's algorithm and stores the computed least weight to other nodes, reweighted using the nodes' $h(v)$ values, as the final weight. The time complexity is $O(V<sup>2</sup>\\log V + VE)$.";
	:aggregateChild :BellmanFordAlgorithm;
	:aggregateChild :DijkstrasAlgorithm;
	rdfs:label "Johnson's algorithm".

:JohnsonTrotter			a :Algorithm;
	rdfs:comment "Generate permutations by transposing elements.";
	rdfs:label "Johnson-Trotter".

:JohnsonTrotterImplementation1 a :Program;
	:implements :JohnsonTrotter;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.theory.csc.uvic.ca/~cos/inf/perm/PermInfo.html>.

:JohnsonTrotterImplementation2 a :Program;
	:implements :JohnsonTrotter;
	:implementationLanguage "C";
	:implementationURL <http://www.theory.csc.uvic.ca/~cos/inf/perm/PermInfo.html>.

:JSort				a :Algorithm;
	rdfs:comment "An in-place sort algorithm that uses strand sort to sort fewer than about 40 items and shuffle sort to sort more.";
	rdfs:subClassOf :InPlaceSort;
	rdfs:label "J sort".

:JSortImplementation1 a :Program;
	:implements :JSort;
	:implementationLanguage "Java";
	:implementationURL <http://cg.scs.carleton.ca/~morin/misc/sortalg/>.

:JumpList			a :DataStructure;
	rdfs:comment "A variant of doubly linked list with items in sorted order and having two levels of additional links that span geometrically increasing distances.  For a  list with $n$ items, the next level is a link from item $i$,  $1 \\leq i \\leq n - \\lfloor n <sup>1/3</sup>\\rfloor$, to  item $i + \\lfloor i <sup>1/3</sup>\\rfloor$.  At the top level, items $1<sup>3</sup>, 2<sup>3</sup>, 3<sup>3</sup>, \\ldots,  \\lfloor n <sup>1/3</sup>\\rfloor <sup>3</sup>$ have backward links, that is, there is a link from item $i<sup>3</sup>$,  $1 &lt; i \\leq \\lfloor n <sup>1/3</sup>\\rfloor <sup>3</sup>$, to  item $(i-1)<sup>3</sup>$.   Search, insert, and delete are $O(n<sup>1/3</sup>)$ worst case.";
	rdfs:label "jump list".

:JumpSearch			a :Algorithm;
	rdfs:comment "Search a sorted array by checking every $j<sup>th</sup>$ item until the right area is found, then doing a linear search.  The optimum for $n$ items is when $j=\\sqrt n$.";
	rdfs:subClassOf :Search;
	rdfs:label "jump search".

:KarnaughMap			a :Algorithm;
	rdfs:comment "A method for minimizing a boolean expression, usually aided by a rectangular map of the value of the expression for all possible input values.  Input values are arranged in a Gray code.  Maximal rectangular groups that cover the inputs where the expression is true give a minimum implementation. <br> <img src=\"../Images/karnaugh.gif\" height=\"225\" width=\"221\">";
	:aggregateChild :GrayCode;
	rdfs:label "Karnaugh map".

:KarnaughMapImplementation1 a :Program;
	:implements :KarnaughMap;
	:implementationLanguage "Java";
	:implementationURL <http://tech-www.informatik.uni-hamburg.de/applets/kvd/>.

:KarpRabin			a :Algorithm;
	rdfs:comment "A string matching algorithm that compares string's  hash values, rather than the strings themselves.  For efficiency, the hash value of the next position in the text is easily computed from the hash value of the current position.";
	rdfs:subClassOf :StringMatching;
	rdfs:label "Karp-Rabin".

:KarpRabinImplementation1 a :Program;
	:implements :KarpRabin;
	:implementationLanguage "C";
	:implementationURL <http://www-igm.univ-mlv.fr/~lecroq/string/>.

:KarpRabinImplementation2 a :Program;
	:implements :KarpRabin;
	:implementationLanguage "C";
	:implementationURL <http://www-igm.univ-mlv.fr/~lecroq/string/node5.html>.

:KarpRabinImplementation3 a :Program;
	:implements :KarpRabin;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/715.srch.c>.

:KarpRabinImplementation4 a :Program;
	:implements :KarpRabin;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/715.srch.c>.

:KAryHeap			a :DataStructure;
	rdfs:comment "A complete tree where every node has a key more extreme (greater or less) than the key of its parent.  Each node has <strong>k</strong> or fewer children.";
	rdfs:subClassOf :CompleteTree;
	rdfs:label "k-ary heap".

:KAryHuffmanCoding		a :Algorithm;
	rdfs:comment "A minimal variable-length coding based on the frequency of each character.  Similar to a Huffman coding, but joins $k$ trees into a k-ary tree at each step, and uses $k$ symbols for each level.";
	rdfs:label "k-ary Huffman coding".

:KAryHuffmanCodingImplementation1 a :Program;
	:implements :KAryHuffmanCoding;
	:implementationLanguage "Java";
	:implementationURL <http://ciips.ee.uwa.edu.au/~morris/Year2/PLDS210/huffman.html>.

:KAryTree			a :DataStructure;
	rdfs:comment "A tree with no more than <strong>k</strong> children for each node.";
	rdfs:subClassOf :Tree;
	rdfs:label "k-ary tree".

:KDBTree			a :DataStructure;
	rdfs:comment "A data structure which splits multidimensional spaces like an adaptive k-d tree, but balances the resulting tree like a B-tree.";
	rdfs:label "k-d-B-tree".

:KDTree				a :DataStructure;
	rdfs:comment "A multidimensional search tree for points in $k$ dimensional space.  Levels of the tree are split along successive dimensions at the points.";
	rdfs:subClassOf :SearchTree;
	rdfs:label "k-d tree".

:KDTreeImplementation1 a :Program;
	:implements :KDTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/352.ins.c>.

:KDTreeImplementation2 a :Program;
	:implements :KDTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/352.range.c>.

:KDTreeImplementation3 a :Program;
	:implements :KDTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/352.srch.c>.

:KDTreeImplementation4 a :Program;
	:implements :KDTree;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/kd-trees.shtml>.

:KDTreeImplementation5 a :Program;
	:implements :KDTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/kd-trees.shtml>.

:KDTreeImplementation6 a :Program;
	:implements :KDTree;
	:implementationLanguage "Fortran";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/kd-trees.shtml>.

:KnuthMorrisPrattAlgorithm	a :Algorithm;
	rdfs:comment "A string matching algorithm that turns the search string into a finite state machine, then runs the machine with the string to be searched as the input string.  Execution time is O(m+n), where m is the length of the search string, and n is the length of the string to be searched.";
	rdfs:subClassOf :StringMatching;
	rdfs:label "Knuth-Morris-Pratt algorithm".

:KnuthMorrisPrattAlgorithmImplementation1 a :Program;
	:implements :KnuthMorrisPrattAlgorithm;
	:implementationLanguage "C";
	:implementationURL <http://www-igm.univ-mlv.fr/~lecroq/string/>.

:KnuthMorrisPrattAlgorithmImplementation2 a :Program;
	:implements :KnuthMorrisPrattAlgorithm;
	:implementationLanguage "C";
	:implementationURL <http://barnyard.syr.edu/quickies/kmp.c>.

:KnuthMorrisPrattAlgorithmImplementation3 a :Program;
	:implements :KnuthMorrisPrattAlgorithm;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/712.srch.c>.

:KnuthMorrisPrattAlgorithmImplementation4 a :Program;
	:implements :KnuthMorrisPrattAlgorithm;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/712.srch.c>.

:KruskalsAlgorithm		a :Algorithm;
	rdfs:comment "An algorithm for computing a minimum spanning tree.  It maintains a set of partial minimum spanning trees, and repeatedly adds the shortest edge in the graph whose vertices are in different partial minimum spanning trees.";
	rdfs:label "Kruskal's algorithm".

:KruskalsAlgorithmImplementation1 a :Program;
	:implements :KruskalsAlgorithm;
	:implementationLanguage "C";
	:implementationURL <http://ciips.ee.uwa.edu.au/~morris/Year2/PLDS210/mst.html>.

:KruskalsAlgorithmImplementation2 a :Program;
	:implements :KruskalsAlgorithm;
	:implementationLanguage "pseudocode";
	:implementationURL <http://students.ceid.upatras.gr/~papagel/project/pseukrus.htm>.

:KWayMergeSort			a :Algorithm;
	rdfs:comment "A merge sort that sorts a data stream using repeated merges.  It distributes the input into $k$ streams by repeatedly reading a block of input that fits in memory, called a <em>run</em>, sorting it, then writing it to the next stream.  It merges runs from the $k$ streams into an output stream.  It then repeatedly distributes the runs in the output stream to the $k$ streams and merges them until there is a single sorted output.";
	rdfs:subClassOf :MergeSort;
	rdfs:label "k-way merge sort".

:LasVegasAlgorithm		a :AlgorithmicTechnique;
	rdfs:comment "A randomized algorithm that always produces correct results, with the only variation from one run to another being its running time.";
	rdfs:subClassOf :RandomizedAlgorithm;
	rdfs:label "Las Vegas algorithm".

:LeftistTree			a :DataStructure;
	rdfs:comment "A priority queue implemented with a variant of a binary tree.  Every node has a count which is the distance to the nearest leaf.  In addition to the heap property, leftist trees are kept so the right descendant of each node has the shorter distance to a leaf.";
	rdfs:subClassOf :PriorityQueue;
	:aggregateChild :BinaryTree;
	:aggregateChild :HeapProperty;
	rdfs:label "leftist tree".

:LeftistTreeImplementation1 a :Program;
	:implements :LeftistTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/516.del.c>.

:LeftistTreeImplementation2 a :Program;
	:implements :LeftistTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/516.del.c>.

:LeftistTreeImplementation3 a :Program;
	:implements :LeftistTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/516.ins.c>.

:LeftistTreeImplementation4 a :Program;
	:implements :LeftistTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/516.ins.c>.

:LeftRotation			a :Algorithm;
	rdfs:comment "(1) In a binary search tree, pushing a node N down and to the left to balance the tree.  N's right child replaces N, and the right child's left child becomes N's right child. (2) In an array, moving all items to the next lower location.  The first item is moved to the last location, which is now vacant. (3) In a list, removing the head and inserting it at the tail.";
	rdfs:label "left rotation".

:LeftRotationImplementation1 a :Program;
	:implements :LeftRotation;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3418.lrot.p>.

:LeftRotationImplementation2 a :Program;
	:implements :LeftRotation;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3414.lrot.c>.

:LeftRotationImplementation3 a :Program;
	:implements :LeftRotation;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.queensu.ca/home/jstewart/applets/bst/source/bst.java>.

:LempelZivWelch			a :Algorithm;
	rdfs:comment "A compression algorithm that codes strings of characters with codes of a fixed number of bits.  Every new string in the input is added to a table until it is full.  The codes of existing strings are output instead of the strings.";
	rdfs:label "Lempel-Ziv-Welch".

:LempelZivWelchImplementation1 a :Program;
	:implements :LempelZivWelch;
	:implementationLanguage "C";
	:implementationURL <http://dogma.net/markn/articles/lzw/lzw.htm>.

:LevelOrderTraversal		a :Algorithm;
	rdfs:comment "Process all nodes of a tree by depth: first the root, then the children of the root, etc.  Equivalent to a breadth-first search from the root.";
	rdfs:label "level-order traversal".

:LinearCongruentialGenerator	a :Algorithm;
	rdfs:comment "A class of algorithms that are pseudo-random number generators.  The next number is generated from the current one by  $r<sub>n+1</sub> = (A \\times r<sub>n</sub> + B)\\bmod M$, where A and M are relatively prime numbers.";
	rdfs:label "linear congruential generator".

:LinearHash			a :Algorithm;
	rdfs:comment "A numeric function that maintains the order of input keys while changing their spacing.";
	rdfs:subClassOf :HashFunction;
	rdfs:label "linear hash".

:LinearHashing			a :DataStructure;
	rdfs:comment "A dynamic hashing table that grows one slot at a time.  It has a family of hash functions, $h<sub>i</sub>$, where the range of $h<sub>i+1</sub>$ is twice the range of $h<sub>i</sub>$.  Slots below a pointer, $p$, have been split.  That is, key, $k$, is in slot $h<sub>i</sub>(k)$ if $h<sub>i</sub>(k) &gt; p$.  Otherwise it is in $h<sub>i+1</sub>(k)$.  To maintain the load factor, slot $p$ can be split (rehashed with $h<sub>i+1</sub>$) and $p$ incremented. When $p$ reaches the end, the ranges are doubled ($i$ is incremented), and $p$ starts over.";
	rdfs:subClassOf :DynamicHashing;
	rdfs:label "linear hashing".

:LinearProbing			a :DataStructure;
	rdfs:comment "A hash table in which a collision is resolved by putting the item in the next empty place in the array following the occupied place.  Even with a moderate load factor, primary clustering tends to slow retrieval.";
	rdfs:subClassOf :HashTable;
	rdfs:label "linear probing".

:LinearProbingImplementation1 a :Program;
	:implements :LinearProbing;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/334.ins.c>.

:LinearProbingImplementation2 a :Program;
	:implements :LinearProbing;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/334.srch.c>.

:LinearProbingSort		a :Algorithm;
	rdfs:comment "Distribute each of $n$ element to one of $m$ locations in an array ($m&gt;n$) based on an interpolation of the element's key.  In case of collisions, put the element in the next empty location.  The array has extra space at the end for overflow.  The second pass packs the elements back into an array of size $n$.";
	rdfs:subClassOf :DistributionSort;
	:aggregateChild :LinearProbing;
	rdfs:label "linear probing sort".

:LinearProbingSortImplementation1 a :Program;
	:implements :LinearProbingSort;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/417.sort.c>.

:LinearProbingSortImplementation2 a :Program;
	:implements :LinearProbingSort;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/417.sort.c>.

:LinearQuadtree			a :DataStructure;
	rdfs:comment "A quadtree implemented as a single array of nodes.";
	rdfs:subClassOf :Quadtree;
	rdfs:label "linear quadtree".

:LinearQuadtreeImplementation1 a :Program;
	:implements :LinearQuadtree;
	:implementationLanguage "C++";
	:implementationURL <http://lcavwww.epfl.ch/~balmelli/software/quadtree/>.

:LinearSearch			a :Algorithm;
	rdfs:comment "Search an array or list by checking items one at a time.";
	rdfs:subClassOf :Search;
	:aggregateChild :MoveToFrontHeuristic;
	rdfs:label "linear search".

:LinearSearchImplementation1 a :Program;
	:implements :LinearSearch;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/311c.srch.c>.

:LinkedList			a :DataStructure;
	rdfs:comment "A list implemented by each item having a link to the next item.  ";
	rdfs:subClassOf :List;
	rdfs:label "linked list".

:LinkedListImplementation1 a :Program;
	:implements :LinkedList;
	:implementationLanguage "C++";
	:implementationURL <http://www.cs.rpi.edu/~musser/gp/lists.html>.

:LinkedListImplementation2 a :Program;
	:implements :LinkedList;
	:implementationLanguage "C";
	:implementationURL <http://users.footprints.net/~kaz/kazlib.html>.

:LinkedListImplementation3 a :Program;
	:implements :LinkedList;
	:implementationLanguage "C++";
	:implementationURL <http://www.fortunecity.com/skyscraper/false/780/linklist.html>.

:List				a :DataStructure;
	rdfs:comment "A collection of items accessible one after another beginning at the head and ending at the tail.";
	rdfs:subClassOf :Bag;
	rdfs:label "list".

:LowerTriangularMatrix		a :DataStructure;
	rdfs:comment "A matrix that is only defined at $(i,j)$ when $i \\geq j$.";
	rdfs:subClassOf :Matrix;
	rdfs:label "lower triangular matrix".

:LowerTriangularMatrixImplementation1 a :Program;
	:implements :LowerTriangularMatrix;
	:implementationLanguage "Fortran";
	:implementationURL <http://gams.nist.gov/serve.cgi/Class/N1>.

:LuckySort			a :Algorithm;
	rdfs:comment "The best possible sort algorithm: it is so lucky that the input is already sorted, and it need do nothing!";
	rdfs:label "lucky sort".

:MalhotraKumarMaheshwariBlockingFlow	a :Algorithm;
	rdfs:comment "Given a flow function and its corresponding residual graph (a maximum-flow problem), select a vertex with the least throughput and greedily push the maximum flow from it to the sink.  This is repeated until all vertices are deleted.";
	rdfs:label "Malhotra-Kumar-Maheshwari blocking flow".

:MarkovChain			a :DataStructure;
	rdfs:comment "A finite state machine with probabilities for each transition, that is, a probability that the next state is $s<sub>j</sub>$ given that the current state is $s<sub>i</sub>$.";
	rdfs:subClassOf :FiniteStateMachine;
	rdfs:label "Markov chain".

:Matrix				a :DataStructure;
	rdfs:comment "A two-dimensional array.  By convention, the first index is the row, and the second index is the column.";
	rdfs:label "matrix".

:MatrixImplementation1 a :Program;
	:implements :Matrix;
	:implementationLanguage "Fortran";
	:implementationURL <http://gams.nist.gov/serve.cgi/Class/N1>.

:MatrixImplementation2 a :Program;
	:implements :Matrix;
	:implementationLanguage "C++";
	:implementationURL <http://gams.nist.gov/serve.cgi/Module/MV++/MV++/12992>.

:Memoization			a :AlgorithmicTechnique;
	rdfs:comment "Save (memoize) a computed answer for later reuse, rather than recomputing the answer.";
	rdfs:label "memoization".

:MergeSort			a :Algorithm;
	rdfs:comment "A sort algorithm that splits the items to be sorted into two groups, recursively sorts each group, and  merges them into a final, sorted sequence.   Run time is $\\Theta$(n log n).";
	rdfs:subClassOf :Sort;
	rdfs:label "merge sort".

:MergeSortImplementation1 a :Program;
	:implements :MergeSort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.utoronto.ca/~neto/teaching/238/16/mergesort.html>.

:MergeSortImplementation2 a :Program;
	:implements :MergeSort;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/implement/handbook/distrib/handbook/algs/4/421.sort.c>.

:MergeSortImplementation3 a :Program;
	:implements :MergeSort;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/implement/handbook/distrib/handbook/algs/4/421.sort.p>.

:MergeSortImplementation4 a :Program;
	:implements :MergeSort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.ubc.ca/spider/harrison/Java/ExtraStorageMergeSortAlgorithm.java>.

:MergeSortImplementation5 a :Program;
	:implements :MergeSort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.ubc.ca/spider/harrison/Java/sorting-demo.html>.

:MergeSortImplementation6 a :Program;
	:implements :MergeSort;
	:implementationLanguage "WOOP/ADA";
	:implementationURL <http://www.auto.tuwien.ac.at/~blieb/woop/merge.html>.

:MergeSortImplementation7 a :Program;
	:implements :MergeSort;
	:implementationLanguage "Scheme";
	:implementationURL <http://www.math.grin.edu/~stone/events/scheme-workshop/mergesort.html>.

:MergeSortImplementation8 a :Program;
	:implements :MergeSort;
	:implementationLanguage "C";
	:implementationURL <http://www.siegfried.sielaff.at/>.

:Metaheuristic			a :AlgorithmicTechnique;
	rdfs:comment "(1) A high-level algorithmic framework or approach that can be specialized to solve optimization problems.  (2) A high-level strategy that guides other heuristics in a search for feasible solutions.";
	rdfs:label "metaheuristic".

:Metaphone			a :Algorithm;
	rdfs:comment "An algorithm to code English words phonetically by reducing them to 16 consonant sounds.  A better variant is double metaphone.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "metaphone".

:MetaphoneImplementation1 a :Program;
	:implements :Metaphone;
	:implementationLanguage "Basic";
	:implementationURL <http://aspell.sourceforge.net/metaphone/>.

:MetaphoneImplementation2 a :Program;
	:implements :Metaphone;
	:implementationLanguage "C";
	:implementationURL <http://aspell.sourceforge.net/metaphone/>.

:MetaphoneImplementation3 a :Program;
	:implements :Metaphone;
	:implementationLanguage "Perl";
	:implementationURL <http://aspell.sourceforge.net/metaphone/>.

:MetaphoneImplementation4 a :Program;
	:implements :Metaphone;
	:implementationLanguage "C++";
	:implementationURL <http://aspell.sourceforge.net/metaphone/>.

:MetaphoneImplementation5 a :Program;
	:implements :Metaphone;
	:implementationLanguage "Java";
	:implementationURL <http://www.wbrogden.com/phonetic/index.html>.

:MetaphoneImplementation6 a :Program;
	:implements :Metaphone;
	:implementationLanguage "Java";
	:implementationURL <http://jakarta.apache.org/commons/codec/>.

:MetaphoneImplementation7 a :Program;
	:implements :Metaphone;
	:implementationLanguage "Java";
	:implementationURL <http://www.lanw.com/java/phonetic/>.

:MillerRabin			a :Algorithm;
	rdfs:comment "A heuristic test for prime numbers.  It repeatedly checks if the number being tested, n, is pseudoprime to a randomly chosen base, a, and there are only trivial square roots of 1, modulo n.  In other words, n is surely composite if $a<sup>n-1</sup> \\neq 1 (mod n)$, where $0 &lt; a &lt; n$.  Some composites may be incorrectly judged to be prime.  ";
	rdfs:subClassOf :Heuristic;
	rdfs:label "Miller-Rabin".

:MinimalPerfectHashing		a :Algorithm;
	rdfs:comment "A perfect hashing function that maps each different key to a distinct integer and has the same number of possible integers as keys.";
	rdfs:subClassOf :PerfectHashing;
	rdfs:subClassOf :HashFunction;
	rdfs:label "minimal perfect hashing".

:MinimalPerfectHashingImplementation1 a :Program;
	:implements :MinimalPerfectHashing;
	:implementationLanguage "C";
	:implementationURL <http://burtleburtle.net/bob/hash/perfect.html>.

:MinimalPerfectHashingImplementation2 a :Program;
	:implements :MinimalPerfectHashing;
	:implementationLanguage "C";
	:implementationURL <http://www.ibiblio.org/pub/Linux/devel/lang/c/!INDEX.short.html>.

:MinimalPerfectHashingImplementation3 a :Program;
	:implements :MinimalPerfectHashing;
	:implementationLanguage "C++";
	:implementationURL <http://www.gnu.org/software/gperf/gperf.html>.

:ModelChecking			a :Algorithm;
	rdfs:comment "Efficiently deciding whether a temporal logic formula is satisfied in a finite state machine model.";
	rdfs:label "model checking".

:MODIFIND			a :Algorithm;
	rdfs:comment "An algorithm to select the k<sup>th</sup> smallest element of an array and partition the array around it.  It partitions around the value of the k<sup>th</sup> element until one boundary passes element k.  If either boundary does not pass element k, that boundary is moved and it partitions again.";
	rdfs:label "MODIFIND".

:MODIFINDImplementation1 a :Program;
	:implements :MODIFIND;
	:implementationLanguage "Rexx";
	:implementationURL <http://www.geocities.com/SiliconValley/Garage/3323/3alg.html>.

:MonotonePriorityQueue		a :DataStructure;
	rdfs:comment "A priority queue in which a key being inserted is never higher in priority than a previously deleted node.";
	rdfs:subClassOf :PriorityQueue;
	rdfs:label "monotone priority queue".

:MonteCarloAlgorithm		a :AlgorithmicTechnique;
	rdfs:comment "A randomized algorithm that may produce incorrect results, but with bounded error probability.";
	rdfs:subClassOf :Heuristic;
	rdfs:label "Monte Carlo algorithm".

:MoveToFrontHeuristic		a :Algorithm;
	rdfs:comment "A heuristic that moves the target of a search to the head of a list so it is found faster next time.";
	rdfs:subClassOf :Heuristic;
	rdfs:label "move-to-front heuristic".

:MoveToRootHeuristic		a :Algorithm;
	rdfs:comment "A heuristic that moves the target of a search to the root of the search tree so it is found faster next time.";
	rdfs:subClassOf :Heuristic;
	rdfs:label "move-to-root heuristic".

:Multigraph			a :DataStructure;
	rdfs:comment "A graph whose edges are unordered pairs of  vertices, and the same pair of vertices can be connected by multiple edges.";
	rdfs:subClassOf :UndirectedGraph;
	rdfs:label "multigraph".

:MultilayerGridFile		a :DataStructure;
	rdfs:comment "A spatial access method which is two or more simultaneous grid files.  Objects reside in the first grid file where it doesn't have to be split across hyperplanes.";
	rdfs:subClassOf :SpatialAccessMethod;
	rdfs:label "multilayer grid file".

:MultiplicationMethod		a :Algorithm;
	rdfs:comment "A hash function that uses the first $p$ bits of the key times an irrational number.";
	rdfs:subClassOf :HashFunction;
	rdfs:label "multiplication method".

:Multiprefix			a :Algorithm;
	rdfs:comment "A generalization of scan in which the partial sums are grouped by keys.";
	rdfs:label "multiprefix".

:MultiSuffixTree		a :DataStructure;
	rdfs:comment "A suffix tree extended to multiple strings by concatenating the strings.";
	rdfs:subClassOf :SuffixTree;
	rdfs:label "multi suffix tree".

:MultiwayTree			a :DataStructure;
	rdfs:comment "A tree with any number of children for each  node.";
	rdfs:subClassOf :Tree;
	rdfs:label "multiway tree".

:MunkresAssignmentAlgorithm	a :Algorithm;
	rdfs:comment "Solve the assignment problem in polynomial time by marking and unmarking entries and covering and uncovering rows and columns.";
	rdfs:label "Munkres' assignment algorithm".

:MunkresAssignmentAlgorithmImplementation1 a :Program;
	:implements :MunkresAssignmentAlgorithm;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.public.iastate.edu/~ddoty/HungarianAlgorithm.html>.

:MunkresAssignmentAlgorithmImplementation2 a :Program;
	:implements :MunkresAssignmentAlgorithm;
	:implementationLanguage "Common Lisp";
	:implementationURL <http://cvs.sourceforge.net/viewcvs.py/*checkout*/clocc/clocc/src/cllib/munkres.lisp?rev=HEAD>.

:NonbalancedMergeSort		a :Algorithm;
	rdfs:comment "A k-way merge sort in which the number of input and  output data streams is different for any particular  pass.  Typically $P$ input streams are merged and distributed to $T$ output streams on one pass followed by a merge of the $T$ inputs and distribution to $P$ outputs.";
	rdfs:subClassOf :KWayMergeSort;
	rdfs:label "nonbalanced merge sort".

:NondeterministicAlgorithm	a :AlgorithmicTechnique;
	rdfs:comment "A conceptual algorithm with more than one allowed step at certain times and which always takes the right or best step.   It is not random, as in randomized algorithm, or indeterminate. Rather it has the supercomputational characteristic of choosing the optimal behavior.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "nondeterministic algorithm".

:NYSIIS				a :Algorithm;
	rdfs:comment "Convert a name to a phonetic coding of up to six characters.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "NYSIIS".

:NYSIISImplementation1 a :Program;
	:implements :NYSIIS;
	:implementationLanguage "SAS";
	:implementationURL <http://csat.samhsa.gov/IDBSE/nysiis.sas>.

:NYSIISImplementation2 a :Program;
	:implements :NYSIIS;
	:implementationLanguage "Rexx";
	:implementationURL <http://www.markcrocker.com/rexxtipsntricks/rxtt28.2.0482.html>.

:NYSIISImplementation3 a :Program;
	:implements :NYSIIS;
	:implementationLanguage "pseudocode";
	:implementationURL <http://www.dropby.com/NYSIIS.html>.

:NYSIISImplementation4 a :Program;
	:implements :NYSIIS;
	:implementationLanguage "Cobol";
	:implementationURL <http://raven.utc.edu/cgi-bin/WA.EXE?A2=ind0102d&L=hp3000-l&P=33747>.

:Octree				a :DataStructure;
	rdfs:comment "A tree to index three dimensions.  Each node has either eight children or no children.";
	rdfs:subClassOf :Tree;
	rdfs:label "octree".

:OpenAddressing			a :Algorithm;
	rdfs:comment "A class of collision resolution schemes in which all items are stored within the hash table.  In case of collision, other positions are computed and checked (a probe sequence) until an empty position is found.  Some ways of computing possible new positions are less efficient because of clustering.";
	rdfs:subClassOf :CollisionResolutionScheme;
	:aggregateChild :Clustering;
	rdfs:label "open addressing".

:OptimalMerge			a :Algorithm;
	rdfs:comment "Merge $n$ sorted sequences of different lengths into one output while minimizing reads.  Only two sequences can be merged at once.  At each step, the two shortest sequences are merged.";
	rdfs:label "optimal merge".

:OptimalMismatch		a :Algorithm;
	rdfs:comment "A string matching algorithm that compares the rarest character first.  When a character doesn't match, the next character in the text beyond the search string determines where the next possible match begins.";
	rdfs:subClassOf :StringMatching;
	rdfs:label "optimal mismatch".

:OptimalMismatchImplementation1 a :Program;
	:implements :OptimalMismatch;
	:implementationLanguage "C";
	:implementationURL <http://www-igm.univ-mlv.fr/~lecroq/string/>.

:OptimalPolyphaseMerge		a :Algorithm;
	rdfs:comment "A polyphase merge which seeks to minimize the number of merge passes by allocating output runs of each pass to the various output files.  Since polyphase merging must have a different number of runs in each file to be efficient, one seeks the optimal way of selecting how many runs go into each output file.  A series of kth order Fibonacci numbers is one way to select the number of runs.";
	rdfs:subClassOf :PolyphaseMerge;
	rdfs:label "optimal polyphase merge".

:OptimalPolyphaseMergeSort	a :Algorithm;
	rdfs:comment "An external sort algorithm that uses optimal polyphase merges.";
	rdfs:subClassOf :ExternalSort;
	rdfs:label "optimal polyphase merge sort".

:OrderedArray			a :DataStructure;
	rdfs:comment "An array whose items have some order.  Usually, it means a sorted array, but may mean not fully ordered, for example, all values less than the median are in the first half.";
	rdfs:subClassOf :Array;
	rdfs:label "ordered array".

:OrderedLinkedList		a :DataStructure;
	rdfs:comment "A linked list whose items are kept in some order.";
	rdfs:subClassOf :LinkedList;
	rdfs:subClassOf :SortedList;
	rdfs:label "ordered linked list".

:OrderedLinkedListImplementation1 a :Program;
	:implements :OrderedLinkedList;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/511.ins.c>.

:OrderedTree			a :DataStructure;
	rdfs:comment "A tree where the children of every node are ordered, that is, there is a first child, second child, third child, etc.";
	rdfs:subClassOf :Tree;
	rdfs:label "ordered tree".

:OrderPreservingMinimalPerfectHashing	a :Algorithm;
	rdfs:comment "A minimal perfect hashing function for keys in $S$ such that if $k1, k2 \\in S$ and $k1 &gt; k2$, then $f(k1) &gt; f(k2)$.";
	rdfs:subClassOf :MinimalPerfectHashing;
	rdfs:label "order preserving minimal perfect hashing".

:OscillatingMergeSort		a :Algorithm;
	rdfs:comment "Given $n$ tape drives, one input and $n-1$ work drives, distribute a portion of the input to $n-2$ tapes, then merge them onto the final tape reading the $n-2$ backward.  Repeat until $n-2$ (backward) merged runs have been created, at which time they are  merged.  Continue building up powers of $n-2$ batches until done.";
	rdfs:subClassOf :ExternalSort;
	rdfs:label "oscillating merge sort".

:OscillatingMergeSortImplementation1 a :Program;
	:implements :OscillatingMergeSort;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/445.sort.p>.

:Pagoda				a :DataStructure;
	rdfs:comment "A priority queue implemented with a variant of a binary tree.  The root points to its children, as in a binary tree.  Every other node points back to its parent and down to its leftmost (if it is a right child) or rightmost (if it is a left child) descendant leaf.  The basic operation is merge or meld, which maintains  the heap property.  An element is inserted by merging it as a singleton.  The root is removed by merging its right and left children.  Merging is bottom-up, merging the leftmost edge of one with the rightmost edge of the other.";
	rdfs:subClassOf :PriorityQueue;
	:aggregateChild :BinaryTree;
	:aggregateChild :HeapProperty;
	:aggregateChild :Meld;
	rdfs:label "pagoda".

:PagodaImplementation1 a :Program;
	:implements :Pagoda;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/515.del.c>.

:PagodaImplementation2 a :Program;
	:implements :Pagoda;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/515.del.c>.

:PagodaImplementation3 a :Program;
	:implements :Pagoda;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/515.ins.c>.

:PagodaImplementation4 a :Program;
	:implements :Pagoda;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/515.ins.c>.

:PagodaImplementation5 a :Program;
	:implements :Pagoda;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/515.merg.c>.

:PagodaImplementation6 a :Program;
	:implements :Pagoda;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/515.merg.c>.

:ParallelPrefixComputation	a :Algorithm;
	rdfs:comment "Calculate a function, f, on all prefixes of an $n$-element array, that is, $s[0], f(s[0], s[1]), f(s[0], f(s[1], s[2])), \\ldots, f(s[0], \\ldots f(s[n-2], s[n-1])\\ldots)$,  using $\\Theta(n)$ processors in $\\Theta(\\log n)$ time. The algorithm is <pre> for j := 0 to lg(n-1) do <br>     for i := $2<sup>j</sup>$ to n-1 parallel-do<br>         s[i] := f(s[i-$2<sup>j</sup>$], s[i]) </pre> where lg is the logarithm base 2, and parallel-do does the innermost computations in parallel.  The function must be associative.";
	rdfs:label "parallel prefix computation".

:PassiveDataStructure		a :DataStructure;
	rdfs:comment "A data structure with is only changed by external threads or processes, in contrast to an active data structure.";
	rdfs:subClassOf :DataStructure;
	rdfs:label "passive data structure".

:PatriciaTree			a :DataStructure;
	rdfs:comment "A compact representation of a trie where all nodes with one child are merged with their  parent.";
	rdfs:subClassOf :Trie;
	rdfs:label "Patricia tree".

:PatriciaTreeImplementation1 a :Program;
	:implements :PatriciaTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3445.ins.c>.

:PatriciaTreeImplementation2 a :Program;
	:implements :PatriciaTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3445.srch.c>.

:PearsonsHash			a :Algorithm;
	rdfs:comment "A hash function that uses an auxiliary array, but no shift or exclusive-or (xor) operations.";
	rdfs:subClassOf :HashFunction;
	rdfs:label "Pearson's hash".

:PearsonsHashImplementation1 a :Program;
	:implements :PearsonsHash;
	:implementationLanguage "C";
	:implementationURL <http://burtleburtle.net/bob/hash/pearson.html>.

:PerfectHashing			a :Algorithm;
	rdfs:comment "A hash function that maps each different key to a distinct integer.  Usually all possible keys must be known beforehand.  A hash table that uses a perfect hash has no collisions.";
	rdfs:subClassOf :HashFunction;
	rdfs:label "perfect hashing".

:PerfectHashingImplementation1 a :Program;
	:implements :PerfectHashing;
	:implementationLanguage "C++";
	:implementationURL <http://www.nist.gov/dads/HTML/minimalPerfectHash.html>.

:PerfectHashingImplementation2 a :Program;
	:implements :PerfectHashing;
	:implementationLanguage "C";
	:implementationURL <http://www.nist.gov/dads/HTML/minimalPerfectHash.html>.

:PerfectHashingImplementation3 a :Program;
	:implements :PerfectHashing;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3316.ins.c>.

:PerfectHashingImplementation4 a :Program;
	:implements :PerfectHashing;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3316.srch.c>.

:PerfectShuffle			a :Algorithm;
	rdfs:comment "A permutation algorithm, or shuffle, that has exactly the same chance of producing any permutation.";
	rdfs:subClassOf :Permutation;
	rdfs:label "perfect shuffle".

:PerfectShuffleImplementation1 a :Program;
	:implements :PerfectShuffle;
	:implementationLanguage "Haskell";
	:implementationURL <http://okmij.org/ftp/Haskell/perfect-shuffle.txt>.

:Permutation			a :Algorithm;
	rdfs:comment "A rearrangement of elements, where none are lost, added, or changed.  The Fisher-Yates shuffle randomly permutes elements.";
	rdfs:subClassOf :Combination;
	:aggregateChild :JohnsonTrotter;
	rdfs:label "permutation".

:PermutationImplementation1 a :Program;
	:implements :Permutation;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.theory.csc.uvic.ca/~cos/inf/perm/PermInfo.html>.

:PermutationImplementation2 a :Program;
	:implements :Permutation;
	:implementationLanguage "C";
	:implementationURL <http://www.theory.csc.uvic.ca/~cos/inf/perm/PermInfo.html>.

:PermutationImplementation3 a :Program;
	:implements :Permutation;
	:implementationLanguage "Java";
	:implementationURL <http://www.merriampark.com/perm.htm>.

:PermutationImplementation4 a :Program;
	:implements :Permutation;
	:implementationLanguage "C";
	:implementationURL <http://remus.rutgers.edu/~rhoads/Code/code.html>.

:PermutationImplementation5 a :Program;
	:implements :Permutation;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/generating-permutations.shtml>.

:PermutationImplementation6 a :Program;
	:implements :Permutation;
	:implementationLanguage "Fortran";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/generating-permutations.shtml>.

:PermutationImplementation7 a :Program;
	:implements :Permutation;
	:implementationLanguage "Mathematica";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/generating-permutations.shtml>.

:PermutationImplementation8 a :Program;
	:implements :Permutation;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/generating-permutations.shtml>.

:PermutationImplementation9 a :Program;
	:implements :Permutation;
	:implementationLanguage "Fortran";
	:implementationURL <http://gams.nist.gov/serve.cgi/Class/N8>.

:PermutationImplementation10 a :Program;
	:implements :Permutation;
	:implementationLanguage "Haskell";
	:implementationURL <http://okmij.org/ftp/Haskell/perfect-shuffle.txt>.

:Pile				a :DataStructure;
	rdfs:comment "An ordered deque, that is, items may only be added  to or removed from the head or the tail. An item is added to the head if it is smaller than the current head.  An item is added to the tail if it is greater than the current tail.  Items are never inserted into the  middle, rather, an additional pile may be created.";
	rdfs:subClassOf :Deque;
	rdfs:label "pile".

:PipelinedDivideAndConquer	a :AlgorithmicTechnique;
	rdfs:comment "A divide and conquer paradigm in which partial results from recursive calls can be used before the calls complete. The technique is often useful for reducing the depth of an algorithm.";
	rdfs:subClassOf :DivideAndConquer;
	rdfs:label "pipelined divide and conquer".

:PLOPHashing			a :DataStructure;
	rdfs:comment "Piecewise linear order-preserving (PLOP) hashing is a spatial access method which splits space into a nonperiodic grid.  Each spatial dimension is divided by nodes of a binary tree.  Object are stored in the grid cell of their centroid.";
	rdfs:label "PLOP-hashing".

:PolynomialApproximationScheme	a :AlgorithmicTechnique;
	rdfs:comment "A set of algorithms ${A<sub>\\epsilon</sub>| \\epsilon &gt; 0\\}$, where each $A<sub>\\epsilon</sub>$ is a $(1+\\epsilon)$-approximation algorithm and the execution time is bounded by a polynomial in the length of the input.  The execution time may depend on the choice of $\\epsilon$.  Sometimes referred to more precisely as polynomial-time approximation scheme.";
	rdfs:label "polynomial approximation scheme".

:PolyphaseMerge			a :Algorithm;
	rdfs:comment "A nonbalanced k-way merge which reduces the number of output files needed by reusing the emptied input file or device as one of the output devices.  This is most efficient if the number of output runs in each output file is different.";
	rdfs:subClassOf :KWayMerge;
	rdfs:label "polyphase merge".

:PolyphaseMergeSort		a :Algorithm;
	rdfs:comment "A merge sort algorithm which reduces the number of intermediate files needed by reusing emptied files.";
	rdfs:subClassOf :MergeSort;
	rdfs:label "polyphase merge sort".

:PolyphaseMergeSortImplementation1 a :Program;
	:implements :PolyphaseMergeSort;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/444.sort.c>.

:PostmansSort			a :Algorithm;
	rdfs:comment "A variant of a bucket sort where attributes of the key are described so the algorithm can allocate buckets efficiently.";
	rdfs:label "postman's sort".

:PostorderTraversal		a :Algorithm;
	rdfs:comment "Process all nodes of a tree by recursively processing all subtrees, then finally processing the root.";
	rdfs:subClassOf :TreeTraversal;
	rdfs:label "postorder traversal".

:PreorderTraversal		a :Algorithm;
	rdfs:comment "Process all nodes of a tree by processing the root, then recursively processing all subtrees.";
	rdfs:subClassOf :TreeTraversal;
	rdfs:label "preorder traversal".

:PrimJarnikAlgorithm		a :Algorithm;
	rdfs:comment "Compute a minimum spanning tree by beginning with any vertex as the current tree.  At each step add a least edge between any vertex not in the tree and any vertex in the tree.  Continue until all vertices have been added.";
	rdfs:label "Prim-Jarnik algorithm".

:PrimJarnikAlgorithmImplementation1 a :Program;
	:implements :PrimJarnikAlgorithm;
	:implementationLanguage "pseudocode";
	:implementationURL <http://students.ceid.upatras.gr/~papagel/project/prim.htm>.

:PrimJarnikAlgorithmImplementation2 a :Program;
	:implements :PrimJarnikAlgorithm;
	:implementationLanguage "Java bytecode";
	:implementationURL <http://students.ceid.upatras.gr/~papagel/project/prim.htm>.

:PriorityQueue			a :AbstractDataType;
	rdfs:comment "An abstract data type to efficiently support finding the item with the highest priority across a series of operations.  The basic operations are: insert, find-minimum (or maximum), and delete-minimum (or maximum).  Some implementations also efficiently support join two priority queues (meld), delete an arbitrary item, and increase the priority of a item (decrease-key).";
	rdfs:subClassOf :AbstractDataType;
	:aggregateChild :Heap;
	:aggregateChild :FibonacciHeap;
	rdfs:label "priority queue".

:PruneAndSearch			a :AlgorithmicTechnique;
	rdfs:comment "Find an optimal value by eliminating a constant fraction of remaining objects at each step.  Eliminated objects are guaranteed not to affect the optimal value.  A logarithmic number of steps reduces the number of objects to a constant, and a brute force approach can then solve it.";
	rdfs:label "prune and search".

:PseudoRandomNumberGenerator	a :Algorithm;
	rdfs:comment "A deterministic algorithm to generate a sequence of numbers with little or no discernible pattern in the numbers, except for broad statistical properties.";
	rdfs:subClassOf :DeterministicAlgorithm;
	rdfs:label "pseudo-random number generator".

:PseudoRandomNumberGeneratorImplementation1 a :Program;
	:implements :PseudoRandomNumberGenerator;
	:implementationLanguage "C++";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/random-numbers.shtml>.

:PseudoRandomNumberGeneratorImplementation2 a :Program;
	:implements :PseudoRandomNumberGenerator;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/random-numbers.shtml>.

:PseudoRandomNumberGeneratorImplementation3 a :Program;
	:implements :PseudoRandomNumberGenerator;
	:implementationLanguage "Fortran";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/random-numbers.shtml>.

:PseudoRandomNumberGeneratorImplementation4 a :Program;
	:implements :PseudoRandomNumberGenerator;
	:implementationLanguage "C";
	:implementationURL <http://remus.rutgers.edu/~rhoads/Code/code.html>.

:PseudoRandomNumberGeneratorImplementation5 a :Program;
	:implements :PseudoRandomNumberGenerator;
	:implementationLanguage "C";
	:implementationURL <http://gams.nist.gov/serve.cgi/Module/C/SERV/11669>.

:PseudoRandomNumberGeneratorImplementation6 a :Program;
	:implements :PseudoRandomNumberGenerator;
	:implementationLanguage "C";
	:implementationURL <http://www.eskimo.com/~scs/C-faq/q13.16.html>.

:PTree				a :DataStructure;
	rdfs:comment "(1) A spatial access method that defines hyperplanes, in addition to the orthogonal dimensions, which node boundaries may parallel.  Space is split by hierarchically nested  polytopes (multidimensional boxes with nonrectangular sides).  The R-tree is a special case that has no additional hyperplanes. (2) A spatial access method that splits space by hierarchically nested polytopes. The R-tree is a special case in which all polytopes are boxes.";
	rdfs:subClassOf :Tree;
	rdfs:subClassOf :SpatialAccessMethod;
	:aggregateChild :Polytope;
	rdfs:label "P-tree".

:PTreeImplementation1 a :Program;
	:implements :PTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/512.ins.c>.

:PTreeImplementation2 a :Program;
	:implements :PTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/512.ins.c>.

:PTreeImplementation3 a :Program;
	:implements :PTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/512.del.c>.

:PTreeImplementation4 a :Program;
	:implements :PTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/512.del.c>.

:PTreeImplementation5 a :Program;
	:implements :PTree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/512.insp.c>.

:PTreeImplementation6 a :Program;
	:implements :PTree;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/512.insp.c>.

:QuadraticProbing		a :Algorithm;
	rdfs:comment "A method of open addressing for a hash table in which a collision is resolved by putting the item in the next empty place given by a probe sequence.  The space between places in the sequence increases quadratically.";
	rdfs:label "quadratic probing".

:QuadraticProbingImplementation1 a :Program;
	:implements :QuadraticProbing;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/336.ins.p>.

:QuadraticProbingImplementation2 a :Program;
	:implements :QuadraticProbing;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/336.ins.p>.

:Quadtree			a :DataStructure;
	rdfs:comment "A tree where each node is split along all <em>d</em> dimensions, leading to 2<sup>d</sup> children.";
	rdfs:subClassOf :Tree;
	rdfs:label "quadtree".

:QuadtreeImplementation1 a :Program;
	:implements :Quadtree;
	:implementationLanguage "C++";
	:implementationURL <http://lcavwww.epfl.ch/~balmelli/software/quadtree/>.

:QuadtreeImplementation2 a :Program;
	:implements :Quadtree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/351.ins.c>.

:QuadtreeImplementation3 a :Program;
	:implements :Quadtree;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/351.srch.c>.

:QuadTrie			a :DataStructure;
	rdfs:comment "A tree in which each node is split according to some subset of the key, typically a character.";
	rdfs:subClassOf :Tree;
	rdfs:label "quad trie".

:QuadTrieImplementation1 a :Program;
	:implements :QuadTrie;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/351b.ins.c>.

:QuadTrieImplementation2 a :Program;
	:implements :QuadTrie;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/351b.srch.c>.

:Queue				a :AbstractDataType;
	rdfs:comment "A collection of items in which only the earliest added item may be accessed.  Basic operations are add (to the tail) or enqueue and delete (from the head) or dequeue.  Delete returns the item removed.  Also known as \"first-in, first-out\" or FIFO.";
	rdfs:subClassOf :AbstractDataType;
	rdfs:label "queue".

:QueueImplementation1 a :Program;
	:implements :Queue;
	:implementationLanguage "Java";
	:implementationURL <http://www.octavian.org/cs/Queue.java>.

:QueueImplementation2 a :Program;
	:implements :Queue;
	:implementationLanguage "Scheme";
	:implementationURL <http://www.accesscom.com/~darius/software/scheme-data-structures/queue.scm>.

:QuickSearch			a :Algorithm;
	rdfs:comment "A string matching algorithm that compares characters from the end of the search string to its beginning.  When a character doesn't match, the next character in the text beyond the search string determines where the next possible match begins.";
	rdfs:subClassOf :StringMatching;
	rdfs:label "quick search".

:QuickSearchImplementation1 a :Program;
	:implements :QuickSearch;
	:implementationLanguage "C";
	:implementationURL <http://www-igm.univ-mlv.fr/~lecroq/string/>.

:Quicksort			a :Algorithm;
	rdfs:comment "Pick an element from the array (the pivot), partition the remaining elements into those greater than and less than this pivot, and recursively sort the partitions. There are many variants of the basic scheme above: to select the pivot, to partition the array, to stop the recursion on small partitions, etc.";
	rdfs:subClassOf :InPlaceSort;
	:aggregateChild :Partition;
	:aggregateChild :Select;
	:aggregateChild :SublinearTimeAlgorithm;
	rdfs:label "quicksort".

:QuicksortImplementation1 a :Program;
	:implements :Quicksort;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf>.

:QuicksortImplementation2 a :Program;
	:implements :Quicksort;
	:implementationLanguage "Java";
	:implementationURL <http://java.sun.com/applets/jdk/1.0/demo/SortDemo/example1.html>.

:QuicksortImplementation3 a :Program;
	:implements :Quicksort;
	:implementationLanguage "C";
	:implementationURL <http://en.wikipedia.org/wiki/Quicksort>.

:QuicksortImplementation4 a :Program;
	:implements :Quicksort;
	:implementationLanguage "Python";
	:implementationURL <http://en.wikipedia.org/wiki/Quicksort>.

:QuicksortImplementation5 a :Program;
	:implements :Quicksort;
	:implementationLanguage "Haskell";
	:implementationURL <http://en.wikipedia.org/wiki/Quicksort>.

:QuicksortImplementation6 a :Program;
	:implements :Quicksort;
	:implementationLanguage "pseudocode";
	:implementationURL <http://en.wikipedia.org/wiki/Quicksort>.

:QuicksortImplementation7 a :Program;
	:implements :Quicksort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.ubc.ca/spider/harrison/Java/sorting-demo.html>.

:QuicksortImplementation8 a :Program;
	:implements :Quicksort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.ubc.ca/spider/harrison/Java/QSortAlgorithm.java>.

:QuicksortImplementation9 a :Program;
	:implements :Quicksort;
	:implementationLanguage "Scheme";
	:implementationURL <http://www.math.grin.edu/~stone/events/scheme-workshop/quicksort.html>.

:QuicksortImplementation10 a :Program;
	:implements :Quicksort;
	:implementationLanguage "Rexx";
	:implementationURL <http://www.markcrocker.com/rexxtipsntricks/rxtt28.2.0470.html>.

:QuicksortImplementation11 a :Program;
	:implements :Quicksort;
	:implementationLanguage "Rexx";
	:implementationURL <http://www.markcrocker.com/rexxtipsntricks/rxtt28.2.0471.html>.

:RadixSort			a :Algorithm;
	rdfs:comment "A multiple pass distribution sort algorithm that distributes each item to a bucket according to part of the item's key beginning with the least significant part of the key. After each pass, items are collected from the buckets, keeping the items in order, then redistributed according to the next most significant part of the key.";
	rdfs:subClassOf :DistributionSort;
	rdfs:label "radix sort".

:RadixSortImplementation1 a :Program;
	:implements :RadixSort;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.math.grin.edu/~stone/courses/fundamentals/radix-sorting.html>.

:RadixSortImplementation2 a :Program;
	:implements :RadixSort;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/424.sort.c>.

:RadixSortImplementation3 a :Program;
	:implements :RadixSort;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/424.sort.c>.

:RadixSortImplementation4 a :Program;
	:implements :RadixSort;
	:implementationLanguage "C";
	:implementationURL <http://ciips.ee.uwa.edu.au/~morris/Year2/PLDS210/radixsort.html>.

:RadixSortImplementation5 a :Program;
	:implements :RadixSort;
	:implementationLanguage "C++";
	:implementationURL <http://www.cubic.org/~submissive/sourcerer/radix.htm>.

:RaggedMatrix			a :DataStructure;
	rdfs:comment "A matrix having irregular numbers of items in each row.";
	rdfs:subClassOf :Matrix;
	rdfs:label "ragged matrix".

:RandomizedBinarySearchTree	a :DataStructure;
	rdfs:comment "A binary search tree in which nodes have a randomly assigned priority.  Updates keep priorities in heap order instead of keeping balance information and doing rebalance operations.";
	rdfs:subClassOf :BinarySearchTree;
	rdfs:label "randomized binary search tree".

:RandomizedBinarySearchTreeImplementation1 a :Program;
	:implements :RandomizedBinarySearchTree;
	:implementationLanguage "Scheme";
	:implementationURL <http://okmij.org/ftp/Scheme/treap.scm>.

:RandomizedRounding		a :Algorithm;
	rdfs:comment "A probabilistic method to convert a solution of a relaxed problem into an approximate solution to the original problem.";
	rdfs:label "randomized rounding".

:RandomizedSearchTree		a :DataStructure;
	rdfs:comment "See randomized binary search tree.";
	rdfs:label "randomized search tree".

:RandomNumberGenerator		a :Algorithm;
	rdfs:comment "See pseudo-random number generator.";
	rdfs:label "random number generator".

:RandomSampling			a :AlgorithmicTechnique;
	rdfs:comment "Using a randomly selected sample of the data to help solve a problem on the whole data.";
	rdfs:label "random sampling".

:RangeSort			a :Algorithm;
	rdfs:comment "A bucket sort where the function to determine the  bucket is based on the range of possible keys.";
	rdfs:subClassOf :BucketSort;
	rdfs:subClassOf :DistributionSort;
	rdfs:label "range sort".

:RatcliffObershelpPatternRecognition	a :Algorithm;
	rdfs:comment "Compute the similarity of two strings as the number of matching characters divided by the total number of characters in the two strings.  Matching characters are those in the longest common subsequence plus, recursively, matching characters in the unmatched region on either side of the longest common subsequence.";
	rdfs:subClassOf :StringMatchingWithErrors;
	rdfs:label "Ratcliff/Obershelp pattern recognition".

:RatcliffObershelpPatternRecognitionImplementation1 a :Program;
	:implements :RatcliffObershelpPatternRecognition;
	:implementationLanguage "C";
	:implementationURL <http://www.gate.net/%7eddata/utilities/simil.c>.

:Rebalance			a :Algorithm;
	rdfs:comment "Restore balance to a tree.";
	rdfs:label "rebalance".

:RebalanceImplementation1 a :Program;
	:implements :Rebalance;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3415.ins.p>.

:RectangularMatrix		a :DataStructure;
	rdfs:comment "An $n \\times m$ matrix, or, one whose size may not be the same in both dimensions.";
	rdfs:label "rectangular matrix".

:RectangularMatrixImplementation1 a :Program;
	:implements :RectangularMatrix;
	:implementationLanguage "Fortran";
	:implementationURL <http://gams.nist.gov/serve.cgi/Class/N1>.

:Recursion			a :AlgorithmicTechnique;
	rdfs:comment "An algorithmic technique where a function, in order to accomplish a task, calls itself with some part of the task.";
	rdfs:label "recursion".

:Recursive			a :DataStructure;
	rdfs:comment "(1) A data structure that is partially composed of other instances of the data structure.  For instance, a tree is composed of smaller trees (subtrees) and leaf nodes, and a list may  have other lists as elements.  (2) An algorithm in which functions might call themselves.  For instance, quicksort or heapify.";
	rdfs:label "recursive".

:RedBlackTree			a :DataStructure;
	rdfs:comment "A nearly-balanced tree that uses an extra bit per  node to maintain balance.  No leaf is more than twice as far from the root as any other.";
	rdfs:subClassOf :BTree;
	:aggregateChild :LeftRotation;
	:aggregateChild :RightRotation;
	rdfs:label "red-black tree".

:RedBlackTreeImplementation1 a :Program;
	:implements :RedBlackTree;
	:implementationLanguage "C";
	:implementationURL <http://ciips.ee.uwa.edu.au/~morris/Year2/PLDS210/red_black.html>.

:RedBlackTreeImplementation2 a :Program;
	:implements :RedBlackTree;
	:implementationLanguage "C";
	:implementationURL <http://www.stanford.edu/~blp/avl/>.

:RedBlackTreeImplementation3 a :Program;
	:implements :RedBlackTree;
	:implementationLanguage "C";
	:implementationURL <http://users.footprints.net/~kaz/kazlib.html>.

:RedBlackTreeImplementation4 a :Program;
	:implements :RedBlackTree;
	:implementationLanguage "C";
	:implementationURL <http://users.footprints.net/~kaz/austin.html>.

:RelationalStructure		a :DataStructure;
	rdfs:comment "The counterpart in formal logic of a data structure or class instance in the object-oriented sense.  Examples are strings, directed graphs, and undirected graphs.  Sets of relational structures generalize the notion of languages as sets of strings.";
	rdfs:label "relational structure".

:RepeatedSquaring		a :Algorithm;
	rdfs:comment "Compute the $n<sup>th</sup>$ power of an expression in  $\\Theta(\\log n)$ steps by repeatedly squaring an intermediate result and multiplying an accumulating value by the intermediate result when appropriate.";
	rdfs:label "repeated squaring".

:RepeatedSquaringImplementation1 a :Program;
	:implements :RepeatedSquaring;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.ucsd.edu/classes/fa96/cse30/lec4/exp.html>.

:RFile				a :DataStructure;
	rdfs:comment "A spatial access method which divides space into a hierarchically of nested boxes.  Objects are indexed in the lowest cell which completely contains them.";
	rdfs:subClassOf :SpatialAccessMethod;
	rdfs:label "R-file".

:RightRotation			a :Algorithm;
	rdfs:comment "(1) In a binary search tree, pushing a node N down and to the right to balance the tree.  N's left child replaces N, and the left child's right child becomes N's left child. (2) In an array, moving all items to the next higher location.  The last item is moved to the first location, which is now vacant. (3) In a list, removing the tail and inserting it at the head.";
	rdfs:label "right rotation".

:RightRotationImplementation1 a :Program;
	:implements :RightRotation;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3414.rrot.c>.

:RightRotationImplementation2 a :Program;
	:implements :RightRotation;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3414.rrot.c>.

:RightRotationImplementation3 a :Program;
	:implements :RightRotation;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.queensu.ca/home/jstewart/applets/bst/source/bst.java>.

:RightThreadedTree		a :DataStructure;
	rdfs:comment "A variant of a threaded tree in which only the right thread, i.e. link to the successor, of each node is maintained.";
	rdfs:subClassOf :ThreadedTree;
	rdfs:label "right-threaded tree".

:RightThreadedTreeImplementation1 a :Program;
	:implements :RightThreadedTree;
	:implementationLanguage "C";
	:implementationURL <http://www.stanford.edu/~blp/avl/>.

:RPlusTree			a :DataStructure;
	rdfs:comment "A spatial access method which splits space with hierarchically nested boxes.  Objects are indexed in each box which intersects them.  The tree is height-balanced.";
	rdfs:subClassOf :SpatialAccessMethod;
	rdfs:label "R<sup>+</sup>-tree".

:RStarTree			a :DataStructure;
	rdfs:comment "A spatial access method which splits space in hierarchically nested, possibly overlapping, boxes.  The tree is height-balanced.  It is similar to the R-tree, but reinserts entries upon overflow, rather than splitting.";
	rdfs:subClassOf :SpatialAccessMethod;
	rdfs:label "R<sup>*</sup>-tree".

:RStarTreeImplementation1 a :Program;
	:implements :RStarTree;
	:implementationLanguage "C++";
	:implementationURL <http://www.cs.ucr.edu/~marioh/spatialindex/>.

:RTree				a :DataStructure;
	rdfs:comment "(1) A spatial access method which splits space with hierarchically nested, and possibly overlapping, boxes.  The tree is height-balanced. (2) A recursion tree.";
	rdfs:label "R-tree".

:RTreeImplementation1 a :Program;
	:implements :RTree;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.bu.edu/faculty/gkollios/rtrees.html>.

:RTreeImplementation2 a :Program;
	:implements :RTree;
	:implementationLanguage "C++";
	:implementationURL <http://www.volny.cz/r-tree/>.

:SBBTree			a :DataStructure;
	rdfs:comment "A symmetric binary B-tree.  Now known as a red-black tree.";
	rdfs:label "SBB tree".

:Scan				a :Algorithm;
	rdfs:comment "A parallel operation in which each element in an array or linked list receives the sum of all previous elements.";
	rdfs:label "scan".

:ScapegoatTree			a :Algorithm;
	rdfs:comment "A binary search tree that needs no balance information. Search time is logarithmic, and the amortized cost of update is logarithmic.";
	rdfs:subClassOf :BinarySearchTree;
	rdfs:label "scapegoat tree".

:Search				a :Algorithm;
	rdfs:comment "To look for a value or item in a data structure.  There are dozens of algorithms, data structures, and approaches.";
	rdfs:label "search".

:SearchTree			a :DataStructure;
	rdfs:comment "A tree where every subtree of a node has keys less than any other subtree of the node to its right.  The keys in a node are conceptually between subtrees and are greater than any keys in subtrees to its left and less than any keys in subtrees to its right.";
	rdfs:subClassOf :Tree;
	rdfs:label "search tree".

:SecantSearch			a :Algorithm;
	rdfs:comment "Search a sorted array by estimating the next position to check based on the values at the two previous positions checked.";
	rdfs:label "secant search".

:Select				a :Algorithm;
	rdfs:comment "A four-part algorithm to select the k<sup>th</sup> smallest element of an array.  Part 1) Consider the array as groups of 5 elements; sort and find the median of each group.  2) Use Select  recursively to find <em>x</em>, the median of the medians. 3) Next partition the array around <em>x</em>.   4) Let $i$ be the number of elements in the low side of the partition.  If $k \\leq i$, use Select recursively to find the k<sup>th</sup> element of the low side.  Otherwise Select the k-i<sup>th</sup> element of the high side.";
	rdfs:label "Select".

:SelectionSort			a :Algorithm;
	rdfs:comment "A sort algorithm that repeatedly looks through remaining items to find the least one and moves it to its final location.  The run time is $\\Theta(n<sup>2</sup>)$, where $n$ is the number of comparisons.  The number of swaps is  $O(n)$.";
	rdfs:subClassOf :InPlaceSort;
	rdfs:label "selection sort".

:SelectionSortImplementation1 a :Program;
	:implements :SelectionSort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.ubc.ca/spider/harrison/Java/sorting-demo.html>.

:SelectionSortImplementation2 a :Program;
	:implements :SelectionSort;
	:implementationLanguage "Java";
	:implementationURL <http://thomas.baudel.name/VisuTri/selectionsort.html>.

:SelectionSortImplementation3 a :Program;
	:implements :SelectionSort;
	:implementationLanguage "Scheme";
	:implementationURL <http://www.math.grin.edu/~stone/events/scheme-workshop/selection.html>.

:SelectionSortImplementation4 a :Program;
	:implements :SelectionSort;
	:implementationLanguage "C";
	:implementationURL <http://www.sci.csuhayward.edu/~billard/cs3240/node29.html>.

:SelectMode			a :Algorithm;
	rdfs:comment "An algorithm to find the mode, or most frequently occurring value, in a group of elements.";
	rdfs:label "select mode".

:SelectModeImplementation1 a :Program;
	:implements :SelectMode;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/523.mode.p>.

:SelfOrganizingHeuristic	a :AlgorithmicTechnique;
	rdfs:comment "Heuristic that reorders a list of elements according to how the elements are accessed.";
	rdfs:label "self-organizing heuristic".

:SelfOrganizingList		a :DataStructure;
	rdfs:comment "A list that reorders the elements based on some self-organizing heuristic to improve average access time.";
	rdfs:subClassOf :List;
	rdfs:label "self-organizing list".

:SeparateChaining		a :DataStructure;
	rdfs:comment "A scheme in which each position in the hash table has a list to handle collisions.  Each position may be just a link to the list (direct chaining) or may be an item and a link, essentially, the head of a list. In the latter, one item is in the table, and other colliding items are in the list.";
	rdfs:subClassOf :Chaining;
	rdfs:subClassOf :CollisionResolutionScheme;
	:aggregateChild :LinkedList;
	rdfs:label "separate chaining".

:SeparateChainingImplementation1 a :Program;
	:implements :SeparateChaining;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3311.ins.c>.

:SeparateChainingImplementation2 a :Program;
	:implements :SeparateChaining;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/3311.srch.c>.

:Set				a :AbstractDataType;
	rdfs:comment "An unordered collection of values where each value occurs at most once. A group of elements with three properties: (1) all elements belong to a universe, (2) either each element is a <em>member</em> of the set or it is not, and (3) the elements are unordered.";
	rdfs:subClassOf :Bag;
	rdfs:subClassOf :AbstractDataType;
	rdfs:label "set".

:SetImplementation1 a :Program;
	:implements :Set;
	:implementationLanguage "C++";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/set-data-structures.shtml>.

:SetImplementation2 a :Program;
	:implements :Set;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/set-data-structures.shtml>.

:SetImplementation3 a :Program;
	:implements :Set;
	:implementationLanguage "Scheme";
	:implementationURL <http://www.accesscom.com/~darius/software/scheme-data-structures/sets.scm>.

:ShadowHeap			a :DataStructure;
	rdfs:comment "A heap, implemented in an array, adjacent to an unordered table.  The <em>shadow</em> is the table nodes and all their (recursive) parents, by array index, in the heap.";
	rdfs:subClassOf :Heap;
	rdfs:label "shadow heap".

:ShadowMerge			a :Algorithm;
	rdfs:comment "An algorithm to merge two heaps by concatenating the smaller heap to the larger, then reordering just the concatenated  nodes and their parents to restore the heap property.";
	rdfs:label "shadow merge".

:ShadowMergeInsert		a :Algorithm;
	rdfs:comment "An algorithm to insert a new node into a shadow heap. The new node is placed in the unordered table. When the table grows beyond some threshold size, table  nodes and all their parents are reordered so everything is a heap.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "shadow merge insert".

:ShannonFanoCoding		a :Algorithm;
	rdfs:comment "A variable-length coding based on the frequency of occurrence of each character.  Divide the characters into two sets with the frequency of each set as close to half as possible, and assign the sets either 0 or 1 coding.  Repeatedly divide the sets until each character has a unique coding.";
	rdfs:label "Shannon-Fano coding".

:ShellSort			a :Algorithm;
	rdfs:comment "The first diminishing increment sort.  On each pass $i$ sets of $n/i$ items are sorted, typically with insertion sort.  On each succeeding pass, $i$ is reduced until it is 1 for the last pass.  A good series of $i$ values is important to efficiency.";
	rdfs:subClassOf :DiminishingIncrementSort;
	:aggregateChild :InsertionSort;
	rdfs:label "Shell sort".

:ShellSortImplementation1 a :Program;
	:implements :ShellSort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.ubc.ca/spider/harrison/Java/ShellSortAlgorithm.java>.

:ShellSortImplementation2 a :Program;
	:implements :ShellSort;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.princeton.edu/~rs/shell/>.

:ShellSortImplementation3 a :Program;
	:implements :ShellSort;
	:implementationLanguage "WOOP/ADA";
	:implementationURL <http://www.auto.tuwien.ac.at/~blieb/woop/shell.html>.

:ShellSortImplementation4 a :Program;
	:implements :ShellSort;
	:implementationLanguage "Java";
	:implementationURL <http://cg.scs.carleton.ca/~morin/misc/sortalg/>.

:ShellSortImplementation5 a :Program;
	:implements :ShellSort;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.nmt.edu/~es421/pascal/sort.htm>.

:ShellSortImplementation6 a :Program;
	:implements :ShellSort;
	:implementationLanguage "Scheme";
	:implementationURL <http://www.math.grin.edu/~stone/events/scheme-workshop/shellsort.html>.

:ShellSortImplementation7 a :Program;
	:implements :ShellSort;
	:implementationLanguage "Fortran";
	:implementationURL <http://lib.stat.cmu.edu/apstat/304>.

:ShellSortImplementation8 a :Program;
	:implements :ShellSort;
	:implementationLanguage "Passport for Windows PFW";
	:implementationURL <http://www.ahml.lib.il.us/pfw/ProcessSaveFile.txt>.

:ShellSortImplementation9 a :Program;
	:implements :ShellSort;
	:implementationLanguage "Forth";
	:implementationURL <http://www.complang.tuwien.ac.at/forth/ftp.dei.isep.ipp.pt/pub/forth/docs/4thsort.txt>.

:ShellSortImplementation10 a :Program;
	:implements :ShellSort;
	:implementationLanguage "Basic";
	:implementationURL <http://www.outer-court.com/basic/echo/T469.HTM>.

:ShellSortImplementation11 a :Program;
	:implements :ShellSort;
	:implementationLanguage "Rexx";
	:implementationURL <http://www.markcrocker.com/rexxtipsntricks/rxtt28.2.0475.html>.

:ShiftOr			a :Algorithm;
	rdfs:comment "A string matching algorithm which keeps an array of bits, R, showing if prefixes of the pattern don't match at the current place.  Before searching, mismatch arrays are computed for each character in the alphabet and saved in an array, S.  For the next position, with the character c, $R = shift(R) or S[c]$.  If the last bit of R is 0, the pattern matches.";
	rdfs:subClassOf :StringMatching;
	rdfs:label "Shift-Or".

:ShiftOrImplementation1 a :Program;
	:implements :ShiftOr;
	:implementationLanguage "C";
	:implementationURL <http://www-igm.univ-mlv.fr/~lecroq/string/node6.html>.

:ShuffleSort			a :Algorithm;
	rdfs:comment "A distribution sort algorithm that begins by removing the first $1/8$ of the items, sorting them (recursively), and putting them in an array.  This creates $n/8$ buckets to which the remaining $7/8$ of the items are distributed.  Each bucket is then sorted, and the buckets are concatenated.";
	rdfs:subClassOf :DistributionSort;
	rdfs:label "shuffle sort".

:SieveOfEratosthenes		a :Algorithm;
	rdfs:comment "An algorithm to find all prime numbers up to a certain $N$. Begin with an (unmarked) array of integers from 2 to $N$.  The first unmarked integer, 2, is the first prime.  Mark every multiple of this prime.  Repeatedly take the next unmarked integer as the next prime and mark every multiple of the prime.";
	rdfs:label "sieve of Eratosthenes".

:SieveOfEratosthenesImplementation1 a :Program;
	:implements :SieveOfEratosthenes;
	:implementationLanguage "C";
	:implementationURL <http://primes.utm.edu/links/programs/sieves/Eratosthenes/>.

:SieveOfEratosthenesImplementation2 a :Program;
	:implements :SieveOfEratosthenes;
	:implementationLanguage "Perl";
	:implementationURL <http://primes.utm.edu/links/programs/sieves/Eratosthenes/>.

:SieveOfEratosthenesImplementation3 a :Program;
	:implements :SieveOfEratosthenes;
	:implementationLanguage "Java";
	:implementationURL <http://primes.utm.edu/links/programs/sieves/Eratosthenes/>.

:SieveOfEratosthenesImplementation4 a :Program;
	:implements :SieveOfEratosthenes;
	:implementationLanguage "Java 5";
	:implementationURL <http://www.javajungle.de/math/primes/PrimeNumberSieve.html>.

:SieveOfEratosthenesImplementation5 a :Program;
	:implements :SieveOfEratosthenes;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.merlyn.demon.co.uk/programs/eratost1.pas>.

:SieveOfEratosthenesImplementation6 a :Program;
	:implements :SieveOfEratosthenes;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.merlyn.demon.co.uk/programs/eratost2.pas>.

:SieveOfEratosthenesImplementation7 a :Program;
	:implements :SieveOfEratosthenes;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.merlyn.demon.co.uk/programs/eratost3.pas>.

:SiftUp				a :Algorithm;
	rdfs:comment "Restoring the heap property by swapping a node with its parent, and repeating the process on the parent until the root is reached or the heap property is satisfied.";
	rdfs:label "sift up".

:SimpleMerge			a :Algorithm;
	rdfs:comment "Merge $n$ sorted streams into one output stream. All the stream heads are compared, and the head with the least key is removed and written to the output. This is repeated until all streams are empty.";
	rdfs:label "simple merge".

:SimulatedAnnealing		a :Algorithm;
	rdfs:comment "A technique to find a good solution to an optimization problem by trying random variations of the current solution.  A worse variation is accepted as the new solution with a probability that decreases as the computation proceeds.  The slower the <em>cooling schedule</em>, or rate of decrease, the more likely the algorithm is to find an optimal or near-optimal solution.";
	rdfs:label "simulated annealing".

:SkdTree			a :DataStructure;
	rdfs:comment "The spatial k-d tree is a spatial access method where successive levels are split along different dimensions.  Objects are indexed by their centroid, and the minimum bounding box of objects in a node are stored in the node.";
	rdfs:label "skd-tree".

:SkipList			a :DataStructure;
	rdfs:comment "A randomized variant of an  ordered linked list with additional, parallel lists. Parallel lists at higher levels skip geometrically more items. Searching begins at the highest level, to quickly get to the right part of the list, then uses progressively lower level lists. A new item is added by randomly selecting a level, then inserting it in order in the lists for that and all lower levels.  With enough levels, searching is $O(\\log n)$.";
	rdfs:subClassOf :OrderedLinkedList;
	:aggregateChild :RandomizedAlgorithm;
	rdfs:label "skip list".

:SkipListImplementation1 a :Program;
	:implements :SkipList;
	:implementationLanguage "C";
	:implementationURL <http://epaperpress.com/sortsearch/txt/skl.txt>.

:SmithAlgorithm			a :Algorithm;
	rdfs:comment "A string matching algorithm which computes the shift value for both the rightmost character of the window and the character preceding it, then uses the maximum of the two values.";
	rdfs:subClassOf :StringMatching;
	rdfs:label "Smith algorithm".

:SmithAlgorithmImplementation1 a :Program;
	:implements :SmithAlgorithm;
	:implementationLanguage "C";
	:implementationURL <http://www-igm.univ-mlv.fr/~lecroq/string/node21.html>.

:SmithWatermanAlgorithm		a :Algorithm;
	rdfs:comment "A means of searching protein databases to find those with the best alignment.";
	rdfs:label "Smith-Waterman algorithm".

:Smoothsort			a :Algorithm;
	rdfs:comment "A variant of heapsort that takes advantage of a partially ordered table.  Performance is O(n) when input is sorted and O(n log n)  performance for worst case.";
	rdfs:label "smoothsort".

:SmoothsortImplementation1 a :Program;
	:implements :Smoothsort;
	:implementationLanguage "guarded command language";
	:implementationURL <http://www.cs.utexas.edu/users/EWD/ewd07xx/EWD796a.PDF>.

:Sort				a :Algorithm;
	rdfs:comment "Arrange items in a predetermined order.  There are dozens of algorithms, the choice of which depends on factors such as the number of items relative to working memory, knowledge of the orderliness of the items or the range of the keys, the cost of comparing keys vs. the cost of moving items, etc.  Most algorithms can be implemented as an in-place sort, and many can be implemented so they are stable, too.";
	rdfs:subClassOf :Permutation;
	rdfs:label "sort".

:SortImplementation1 a :Program;
	:implements :Sort;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/sorting.shtml>.

:SortImplementation2 a :Program;
	:implements :Sort;
	:implementationLanguage "C++";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/sorting.shtml>.

:SortImplementation3 a :Program;
	:implements :Sort;
	:implementationLanguage "Fortran";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/sorting.shtml>.

:SortImplementation4 a :Program;
	:implements :Sort;
	:implementationLanguage "Mathematica";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/sorting.shtml>.

:SortImplementation5 a :Program;
	:implements :Sort;
	:implementationLanguage "Java";
	:implementationURL <http://www.cs.brockport.edu/cs/java/apps/sorters/simplesort.html>.

:SortedArray			a :DataStructure;
	rdfs:comment "An array whose items are kept sorted, often so searching is faster.";
	rdfs:subClassOf :Array;
	rdfs:label "sorted array".

:SortedArrayImplementation1 a :Program;
	:implements :SortedArray;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/321.ins.c>.

:SortedList			a :DataStructure;
	rdfs:comment "A list whose items are kept sorted.";
	rdfs:subClassOf :List;
	rdfs:label "sorted list".

:SortedListImplementation1 a :Program;
	:implements :SortedList;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/5/511.ins.c>.

:Soundex			a :Algorithm;
	rdfs:comment "An algorithm to code surnames phonetically by reducing them to the first letter and up to three digits, where each digit is one of six consonant sounds.  This reduces matching problems from different spellings.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "soundex".

:SoundexImplementation1 a :Program;
	:implements :Soundex;
	:implementationLanguage "C";
	:implementationURL <http://physics.nist.gov/cuu/Reference/soundex.html>.

:SoundexImplementation2 a :Program;
	:implements :Soundex;
	:implementationLanguage "Java";
	:implementationURL <http://jakarta.apache.org/commons/codec/>.

:SoundexImplementation3 a :Program;
	:implements :Soundex;
	:implementationLanguage "Visual Basic";
	:implementationURL <http://www.source-code.biz/snippets/vbasic/4.htm>.

:SoundexImplementation4 a :Program;
	:implements :Soundex;
	:implementationLanguage "Rexx";
	:implementationURL <http://www.markcrocker.com/rexxtipsntricks/rxtt28.2.0482.html>.

:SoundexImplementation5 a :Program;
	:implements :Soundex;
	:implementationLanguage "Cobol";
	:implementationURL <http://raven.utc.edu/cgi-bin/WA.EXE?A2=ind0102d&L=hp3000-l&P=33747>.

:SparseMatrix			a :DataStructure;
	rdfs:comment "A matrix that has relatively few non-zero (or \"interesting\") entries.  It may be represented in much less than $n \\times m$ space.";
	rdfs:subClassOf :Matrix;
	rdfs:label "sparse matrix".

:SparseMatrixImplementation1 a :Program;
	:implements :SparseMatrix;
	:implementationLanguage "C";
	:implementationURL <http://gams.nist.gov/serve.cgi/Module/HBIO/HBIO/13020>.

:Sparsification			a :AlgorithmicTechnique;
	rdfs:comment "Technique for designing dynamic graph algorithms, which when applicable transform a time bound of $T(n,m)$ onto $O(T(n,n))$, where $m$ is the number of edges and $n$ is the number of vertices of the given graph.";
	rdfs:label "sparsification".

:SpiralStorage			a :DataStructure;
	rdfs:comment "A dynamic hashing table that grows a few slots at a time.  It uses a hash function, $h$, with a range of $[0,1)$.  For a key, $k$, an intermediate value, $x=\\lceil S-h(k)\\rceil +h(k)$, is computed to find the final slot, $\\lfloor d<sup>x</sup>\\rfloor$, where $d&gt;1$ is called the growth factor.  To increase the number of slots, increase $S$ to $S'$ and rehash any keys from  $\\lfloor d<sup>S</sup>\\rfloor$ to $\\lfloor d<sup>S'</sup>\\rfloor-1$.";
	rdfs:subClassOf :DynamicHashing;
	rdfs:label "spiral storage".

:SplayTree			a :DataStructure;
	rdfs:comment "A binary search tree in which operations that access nodes restructure the tree.";
	rdfs:subClassOf :BinarySearchTree;
	:aggregateChild :MoveToRootHeuristic;
	rdfs:label "splay tree".

:SplayTreeImplementation1 a :Program;
	:implements :SplayTree;
	:implementationLanguage "C";
	:implementationURL <http://users.footprints.net/~kaz/austin.html>.

:SplayTreeImplementation2 a :Program;
	:implements :SplayTree;
	:implementationLanguage "Java";
	:implementationURL <ftp://ftp.cs.cmu.edu/user/sleator/splaying/>.

:SplayTreeImplementation3 a :Program;
	:implements :SplayTree;
	:implementationLanguage "C";
	:implementationURL <ftp://ftp.cs.cmu.edu/user/sleator/splaying/>.

:SquareMatrix			a :DataStructure;
	rdfs:comment "A $n \\times n$ matrix, i.e., one whose size is the same in both dimensions.";
	rdfs:label "square matrix".

:SquareRoot			a :Algorithm;
	rdfs:comment "This describes a \"long hand\" or manual method of calculating or extracting square roots.  Calculation of a square root by hand is a little like long-hand division. </p> <p> Suppose you need to find the square root of 66564. Set up a \"division\" with the number under the radical. Mark off pairs of digits, starting from the decimal point.  (Here the decimal point is a period (.) and a comma (,) marks pairs of digits.) <pre>               ___________	<br>             \\/  6,65,64.	<br> </pre> Look at the leftmost digit(s) (6 in this case).  What is the largest number whose square is less than or equal to it?  It is 2, whose square is 4.  Write 2 above, write the square below and subtract. <pre>               __2________	<br>             \\/  6,65,64.	<br>                -4		<br>               ----		<br>                 2		<br> </pre> Now bring down the next two digits (65).  The next \"divisor\" is double the number on top (2x2=4) and some other digit in the units position (4_). <pre>               __2________	<br>             \\/  6,65,64.	<br>                -4		<br>                -----		<br>             4_ ) 265		<br> </pre> What is the largest number that we can put in the units and multiply times the divisor and still be less than or equal to what we have? (Algebraically, what is d such that $d \\times 4d \\leq 265$?) It looks like 6 might work (since 6 * 40 = 240), but 6 is too big, since 6 * 46 = 276. <pre>               __2__6_____	<br>             \\/  6,65,64.	<br>                -4		<br>                -----		<br>             46 ) 265		<br>                  276   TOO BIG	<br> </pre> So try 5 instead. <pre>               __2__5_____	<br>             \\/  6,65,64.	<br>                -4		<br>                -----		<br>             45 ) 265		<br>                 -225		<br>                 -------		<br>                   40		<br> </pre> Repeat: bring down the next two digits, and double the number on top (2x25=50) to make a \"divisor\", with another unit. <pre>               __2__5_____	<br>             \\/  6,65,64.	<br>                -4		<br>                -----		<br>             45 ) 265		<br>                 -225		<br>                 -------		<br>             50_ ) 4064		<br> </pre> It looks like 8 would work.  Let's see. <pre>               __2__5__8__	<br>             \\/  6,65,64.	<br>                -4		<br>                -----		<br>             45 ) 265		<br>                 -225		<br>                 -------		<br>             508 ) 4064		<br>                  -4064		<br>                  ------		<br>                      0		<br> </pre> </p> <p> So the square root of 66564 is 258.  You can continue for as many decimal places as you need: just bring down more pairs of zeros. </p> <p> <strong>Why does this work?</strong> </p> <p> Consider $(10A + B)<sup>2</sup> = 100A<sup>2</sup> + 2 \\times 10AB + B<sup>2</sup>$ and think about finding the area of a square. Remember that 10A + B is just the numeral with B in the units place and A in the higher position.  For 42, A=4 and B=2, so $10 \\times 4 + 2 = 42$. </p> <p> <img src=\"../Images/squareRoot.gif\" height=\"205\" width=\"175\" alt=\"diagram of a square that is 10A + B on a side showing a 100A squared  rectangle, two 10AB rectangles, and a B squared rectangle\"> </p> <p> The area of the two skinny rectangles is  $2 \\times 10A \\times B$.  The tiny square is $B<sup>2</sup>$. If we know A and the area of the square, S, what B should we choose?   </p> <p> We previously subtracted $A<sup>2</sup>$ from S.  To scale to $100A<sup>2</sup>$, we bring down two more digits (a factor of 100) of the size of S.  We write down twice A (2A), but shifted one place to leave room for B ($10 \\times 2A$ or $2 \\times 10A$).  Now we add B to get  $2 \\times 10A + B$.  Multiplying by B gives us $2 \\times 10AB +  B<sup>2</sup>$.  When we subtract that from the remainder (remember we already subtracted $A<sup>2</sup>$), we have subtracted exactly $(10A + B)<sup>2</sup>$.  That is, we have improved our knowledge of the square root by one digit, B. </p> <p> We take whatever remains, scale again by 100, by bringing down two more digits, and repeat the process. </p>";
	rdfs:label "square root".

:SquareRootImplementation1 a :Program;
	:implements :SquareRoot;
	:implementationLanguage "C";
	:implementationURL <http://gams.nist.gov/serve.cgi/Class/C2/>.

:SquareRootImplementation2 a :Program;
	:implements :SquareRoot;
	:implementationLanguage "Fortran";
	:implementationURL <http://gams.nist.gov/serve.cgi/Class/C2/>.

:SquareRootImplementation3 a :Program;
	:implements :SquareRoot;
	:implementationLanguage "C";
	:implementationURL <http://www.azillionmonkeys.com/qed/sqroot.html>.

:SquareRootImplementation4 a :Program;
	:implements :SquareRoot;
	:implementationLanguage "Assembler";
	:implementationURL <http://www.azillionmonkeys.com/qed/sqroot.html>.

:Stack				a :AbstractDataType;
	rdfs:comment "A collection of items in which only the most recently added item may be removed.  The latest added item is at the top.  Basic operations are push and pop.  Often top and isEmpty are available, too. Also known as \"last-in, first-out\" or LIFO.";
	rdfs:subClassOf :AbstractDataType;
	rdfs:label "stack".

:StackImplementation1 a :Program;
	:implements :Stack;
	:implementationLanguage "Scheme";
	:implementationURL <http://www.math.grin.edu/~stone/events/scheme-workshop/stacks.html>.

:StDigraph			a :DataStructure;
	rdfs:comment "A directed acyclic graph with two specially marked nodes, the source $s$ and the sink $t$.";
	rdfs:subClassOf :DirectedAcyclicGraph;
	rdfs:label "st-digraph".

:StoogeSort			a :Algorithm;
	rdfs:comment "A terribly inefficient sort algorithm that swaps the top and bottom items if needed, then (recursively) sorts the bottom two-thirds, then the top two-thirds, then the bottom two-thirds again.";
	rdfs:label "stooge sort".

:StoogeSortImplementation1 a :Program;
	:implements :StoogeSort;
	:implementationLanguage "Java";
	:implementationURL <http://cg.scs.carleton.ca/~morin/misc/sortalg/>.

:StrandSort			a :Algorithm;
	rdfs:comment "A sort algorithm that works well if many items are in order. Extract a sublist by moving the first remaining item to it.  For each remaining item, if it is greater than the last item of the sublist, append it. Merge the sublist into a final, sorted list.  Repeatedly extract and merge  sublists until all items are sorted.  Handle two or fewer items as special cases.";
	rdfs:subClassOf :Sort;
	rdfs:label "strand sort".

:StrictlyLowerTriangularMatrix	a :DataStructure;
	rdfs:comment "A matrix that is only defined at $(i,j)$ when $i &gt; j$.";
	rdfs:subClassOf :LowerTriangularMatrix;
	rdfs:label "strictly lower triangular matrix".

:StrictlyUpperTriangularMatrix	a :DataStructure;
	rdfs:comment "A matrix that is only defined at $(i,j)$ when $i &lt; j$.";
	rdfs:subClassOf :UpperTriangularMatrix;
	rdfs:label "strictly upper triangular matrix".

:String				a :DataStructure;
	rdfs:comment "A list of characters, usually implemented as an array. Informally a word, phrase, sentence, etc. Since text processing is so common, a special type with substring operations is often available.";
	rdfs:label "string".

:StringMatchingWithErrors	a :Algorithm;
	rdfs:comment "Searching for approximate (e.g., up to a predefined number of symbol mismatches, insertions, and deletions) occurrences of a pattern string in a text string.  Preprocessing, e.g., building an index, may or may not be allowed.";
	rdfs:label "string matching with errors".

:StringMatchingWithErrorsImplementation1 a :Program;
	:implements :StringMatchingWithErrors;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/approximate-pattern-matching.shtml>.

:StringMatchingWithErrorsImplementation2 a :Program;
	:implements :StringMatchingWithErrors;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.cs.sunysb.edu/~algorith/files/approximate-pattern-matching.shtml>.

:StringMatchingWithMismatches	a :Algorithm;
	rdfs:comment "The special case of string matching with errors where mismatches are the only type of error allowed.";
	rdfs:subClassOf :StringMatchingWithErrors;
	rdfs:label "string matching with mismatches".

:SuffixArray			a :DataStructure;
	rdfs:comment "An array of all starting positions of suffixes of a string in lexicographical order, which allows a binary search.";
	rdfs:subClassOf :OrderedArray;
	:aggregateChild :Suffix;
	:aggregateChild :BinarySearch;
	rdfs:label "suffix array".

:SuffixTree			a :DataStructure;
	rdfs:comment "A compact representation of a trie corresponding to the suffixes of a given string where all nodes with one child are merged with their parents.";
	rdfs:subClassOf :PatriciaTree;
	rdfs:subClassOf :Trie;
	rdfs:label "suffix tree".

:SuffixTreeImplementation1 a :Program;
	:implements :SuffixTree;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.ucdavis.edu/~gusfield/strmat.html>.

:SymmetryBreaking		a :AlgorithmicTechnique;
	rdfs:comment "To differentiate parts of a structure, such as a graph, which locally look the same to all vertices.  Usually implemented with randomization.";
	rdfs:label "symmetry breaking".

:TailRecursion			a :AlgorithmicTechnique;
	rdfs:comment "A special form of recursion where the last operation of a function is a recursive call.  The recursion may be optimized away by executing the call in the current stack frame and returning its result rather than creating a new stack frame.";
	rdfs:label "tail recursion".

:ThreadedBinaryTree		a :DataStructure;
	rdfs:comment "See threaded tree.";
	rdfs:label "threaded binary tree".

:ThreadedTree			a :DataStructure;
	rdfs:comment "A binary search tree in which each node uses an otherwise-empty left child link to refer to the node's in-order predecessor and an empty right child link to refer to its in-order successor.";
	rdfs:subClassOf :BinaryTree;
	rdfs:label "threaded tree".

:ThreadedTreeImplementation1 a :Program;
	:implements :ThreadedTree;
	:implementationLanguage "C";
	:implementationURL <http://www.stanford.edu/~blp/avl/>.

:ThreeWayMergeSort		a :Algorithm;
	rdfs:comment "A k-way merge sort which uses three input and three output streams.";
	rdfs:subClassOf :KWayMergeSort;
	rdfs:label "three-way merge sort".

:TopDownRadixSort		a :Algorithm;
	rdfs:comment "A recursive bucket sort where elements are distributed based on succeeding pieces (characters) of the key.";
	rdfs:subClassOf :BucketSort;
	rdfs:label "top-down radix sort".

:TopDownRadixSortImplementation1 a :Program;
	:implements :TopDownRadixSort;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/424b.sort.c>.

:TopDownRadixSortImplementation2 a :Program;
	:implements :TopDownRadixSort;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/424b.sort.c>.

:Tournament			a :Algorithm;
	rdfs:comment "Find the maximum of a set of $n$ elements in  $\\lceil\\log n\\rceil$ \"rounds\" (passes) by \"playing\" (comparing) pairs of elements and advancing the winner (greater) of each pair to the next round.  It takes $n-1$ comparisons, like linear search, but may be parallelized, extended to also find the second greatest element, etc.";
	rdfs:label "tournament".

:TournamentImplementation1 a :Program;
	:implements :Tournament;
	:implementationLanguage "C";
	:implementationURL <http://www.cs.engr.uky.edu/~lewis/essays/algorithms/tournaments/tournmnt.html>.

:TransposeSequentialSearch	a :Algorithm;
	rdfs:comment "Search an array or list by checking items one at a time.  If the value is found, swap it with its predecessor so it is found faster next time.";
	rdfs:label "transpose sequential search".

:TransposeSequentialSearchImplementation1 a :Program;
	:implements :TransposeSequentialSearch;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/313.srch.c>.

:Treap				a :DataStructure;
	rdfs:comment "A binary search tree in which nodes have another key, called the priority.  Operations also keep the nodes heap ordered with regard to the priority.";
	rdfs:subClassOf :BinarySearchTree;
	rdfs:label "treap".

:TreapImplementation1 a :Program;
	:implements :Treap;
	:implementationLanguage "Scheme";
	:implementationURL <http://okmij.org/ftp/Scheme/treap.scm>.

:Tree				a :DataStructure;
	rdfs:comment "(1) A data structure accessed beginning at the root node.  Each node is either a leaf or an internal node.  An internal node has one or more child nodes and is called the parent of its child nodes.  All children of the same node are siblings. Contrary to a physical tree, the root is usually depicted at the top of the structure, and the leaves are depicted at the bottom. (2) A connected, undirected, acyclic graph.  It is rooted and ordered unless otherwise specified. <br> <img src=\"../Images/tree.gif\" height=\"225\" width=\"201\">";
	rdfs:label "tree".

:Treesort1			a :Algorithm;
	rdfs:comment "A sort algorithm that first builds a binary search tree of the keys, then accesses the keys with an in-order traversal.";
	rdfs:subClassOf :Sort;
	:aggregateChild :BinarySearchTree;
	:aggregateChild :InOrderTraversal;
	rdfs:label "treesort (1)".

:Treesort1Implementation1 a :Program;
	:implements :Treesort1;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/4/426.treesort.p>.

:Treesort2			a :Algorithm;
	rdfs:comment "Variants of heapsort.";
	rdfs:subClassOf :Heapsort;
	:aggregateChild :BalancedBinarySearchTree;
	:aggregateChild :Heap;
	rdfs:label "treesort (2)".

:Trie				a :DataStructure;
	rdfs:comment "A tree for storing strings in which there is one node for every common prefix.  The strings are stored in extra leaf nodes.";
	rdfs:subClassOf :Tree;
	rdfs:label "trie".

:TrieImplementation1 a :Program;
	:implements :Trie;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/3/344.ins.c>.

:TrieImplementation2 a :Program;
	:implements :Trie;
	:implementationLanguage "Scheme";
	:implementationURL <http://www.accesscom.com/~darius/software/scheme-data-structures/trie.scm>.

:Tripartition			a :Algorithm;
	rdfs:comment "To partition array elements into three groups.";
	rdfs:label "tripartition".

:TwinGridFile			a :DataStructure;
	rdfs:comment "A point access method which is two simultaneous  grid files.  Points are shuffled between the primary and secondary file to minimize the total size.";
	rdfs:subClassOf :PointAccessMethod;
	rdfs:label "twin grid file".

:TwoChoiceHashing		a :DataStructure;
	rdfs:comment "A variant of a hash table in which keys are added by hashing with two hash functions.  The key is put in the array position with the fewer (colliding) keys.   Some collision resolution scheme is needed, unless keys are kept in buckets.  The average-case cost of a successful search is $O(2 + (m-1)/n)$, where m is the number of keys and n is the size of the array. The most collisions is $\\log<sub>2</sub> \\ln n + \\Theta(m/n)$ with high probability.";
	rdfs:subClassOf :HashTable;
	:aggregateChild :Array;
	:aggregateChild :HashFunction;
	rdfs:label "2-choice hashing".

:TwoLeftHashing			a :DataStructure;
	rdfs:comment "A dictionary implemented with two hash tables of equal size, $T<sub>1</sub>$ and $T<sub>2</sub>$, and two different hash functions, $h<sub>1</sub>$ and $h<sub>2</sub>$. A new key is put in table 2 only if there are fewer (colliding) keys at $T<sub>2</sub>[h<sub>2</sub>(key)]$ than at $T<sub>1</sub>[h<sub>1</sub>(key)]$, otherwise it is put in table 1. With $n$ keys and two tables of size $n/2$, the most collisions is $0.69... \\log<sub>2</sub> \\ln n +  O(1)$ with high probability. ";
	rdfs:subClassOf :HashTable;
	:aggregateChild :Array;
	:aggregateChild :HashFunction;
	rdfs:label "2-left hashing".

:TwoLevelGridFile		a :DataStructure;
	rdfs:comment "A point access method which is two levels of  grid files.  The first level addresses second level grid files.";
	rdfs:subClassOf :PointAccessMethod;
	rdfs:label "two-level grid file".

:Two34Tree			a :DataStructure;
	rdfs:comment "A B-tree of order 4, that is, internal nodes have two, three, or four children.";
	rdfs:subClassOf :BTree;
	rdfs:label "2-3-4 tree".

:Two3Tree			a :DataStructure;
	rdfs:comment "A B-tree of order 3, that is, internal nodes have two or three children.";
	rdfs:subClassOf :BTree;
	rdfs:label "2-3 tree".

:TwoWayAlgorithm		a :Algorithm;
	rdfs:comment "Partition (\"factor\") the pattern, $x$, into left, $x<sub>l</sub>$, and right, $x<sub>r</sub>$, parts in such a way to optimize searching.  Compare $x<sub>r</sub>$ left to right then, if it matches, compare $x<sub>l</sub>$ right to left.";
	rdfs:subClassOf :Algorithm;
	rdfs:label "Two Way algorithm".

:TwoWayAlgorithmImplementation1 a :Program;
	:implements :TwoWayAlgorithm;
	:implementationLanguage "C";
	:implementationURL <http://www-igm.univ-mlv.fr/~lecroq/string/>.

:TwoWayMergeSort		a :Algorithm;
	rdfs:comment "A k-way merge sort that sorts a data stream using repeated merges.  It distributes the input into two streams by repeatedly reading a block of input that fits in memory, a <em>run</em>, sorting it, then writing it to the next stream.  It merges runs from the two streams into an output stream.  It then repeatedly distributes the runs in the output stream to the two streams and merges them until there is a single sorted output.";
	rdfs:subClassOf :KWayMergeSort;
	rdfs:label "two-way merge sort".

:UndirectedGraph		a :DataStructure;
	rdfs:comment "A graph whose edges are <em>unordered</em> pairs of  vertices.  That is, each edge connects two vertices.";
	rdfs:subClassOf :Graph;
	rdfs:label "undirected graph".

:UniformHashing			a :Algorithm;
	rdfs:comment "A conceptual method of open addressing for a hash table. A collision is resolved by putting the item in the next empty place given by a probe sequence which is independent of sequences for all other key.";
	rdfs:label "uniform hashing".

:UniformMatrix			a :DataStructure;
	rdfs:comment "A matrix having the same number of items in each row.";
	rdfs:subClassOf :Matrix;
	rdfs:label "uniform matrix".

:UnionOfAutomata		a :Algorithm;
	rdfs:comment "An algorithm to find an automaton which accepts everything which the automata accept individually.";
	rdfs:label "union of automata".

:UnionOfAutomataImplementation1 a :Program;
	:implements :UnionOfAutomata;
	:implementationLanguage "C";
	:implementationURL <http://www.dcc.uchile.cl/~rbaeza/handbook/algs/7/716.unaut.c>.

:UnShuffleSort			a :Algorithm;
	rdfs:comment "A distribution sort with two phases.  In the first phase, the inputs are distributed among doubly-ended queues keeping the items in each queue ordered and creating a new queue when there is no place on an existing queue.  The second phase is an  ideal merge in which the item to be removed is determined by keeping the queues in a priority queue.";
	rdfs:subClassOf :DistributionSort;
	rdfs:label "UnShuffle sort".

:UpperTriangularMatrix		a :DataStructure;
	rdfs:comment "A matrix that is only defined at $(i,j)$ when $i \\leq j$.";
	rdfs:subClassOf :Matrix;
	rdfs:label "upper triangular matrix".

:UpperTriangularMatrixImplementation1 a :Program;
	:implements :UpperTriangularMatrix;
	:implementationLanguage "Fortran";
	:implementationURL <http://gams.nist.gov/serve.cgi/Class/N1>.

:VanEmdeBoasPriorityQueue	a :DataStructure;
	rdfs:comment "An efficient implementation of priority queues where insert, delete, get minimum, get maximum, etc. take  O(log log N) time, where N is the total possible number of keys.  Depending on the circumstance, the implementation is null (if the queue is empty), an integer (if the queue has one integer), a bit vector of size N (if N is small), or a special data structure: an array of priority queues, called the bottom queues, and one more priority queue of array indexes of the bottom queues.";
	rdfs:subClassOf :PriorityQueue;
	:aggregateChild :BitVector;
	:aggregateChild :Array;
	rdfs:label "van Emde-Boas priority queue".

:ViterbiAlgorithm		a :Algorithm;
	rdfs:comment "An algorithm to compute the optimal (most likely) state sequence in a hidden Markov model given a sequence of observed outputs.";
	:aggregateChild :HiddenMarkovModel;
	rdfs:label "Viterbi algorithm".

:VittersAlgorithm		a :Algorithm;
	rdfs:comment "An adaptive Huffman coding scheme.  Typically this produces codings the same length as or shorter than static Huffman coding. In the worst case, this uses one more bit per codeword.";
	rdfs:subClassOf :AdaptiveHuffmanCoding;
	:aggregateChild :FullBinaryTree;
	rdfs:label "Vitter's algorithm".

:VittersAlgorithmImplementation1 a :Program;
	:implements :VittersAlgorithm;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.netlib.org/toms/673>.

:WeakHeap			a :DataStructure;
	rdfs:comment "A relaxed heap satisfying the following three conditions: (1) every key in the right subtree of a node is greater      than the key stored in the node itself,  (2) the root has no left child, and (3) leaves are only found on the last two levels of the tree.";
	rdfs:subClassOf :Heap;
	rdfs:label "weak-heap".

:WeakHeapSort			a :Algorithm;
	rdfs:comment "A sort algorithm that builds a weak-heap, then repeatedly extracts the maximum item.  In the worst case, the run time is O(n log n + 0.1 n).";
	rdfs:subClassOf :Sort;
	rdfs:label "weak-heap sort".

:WeakHeapSortImplementation1 a :Program;
	:implements :WeakHeapSort;
	:implementationLanguage "C";
	:implementationURL <http://www.informatik.uni-freiburg.de/~edelkamp/WeakHeapsort/>.

:ZellersCongruence		a :Algorithm;
	rdfs:comment "An algorithm to find the day of the week for any date.";
	rdfs:label "Zeller's congruence".

:ZellersCongruenceImplementation1 a :Program;
	:implements :ZellersCongruence;
	:implementationLanguage "Pascal";
	:implementationURL <http://www.merlyn.demon.co.uk/zeller-c.htm#ZC>.

:ZellersCongruenceImplementation2 a :Program;
	:implements :ZellersCongruence;
	:implementationLanguage "JavaScript";
	:implementationURL <http://www.merlyn.demon.co.uk/zeller-c.htm#ZC>.

:ZellersCongruenceImplementation3 a :Program;
	:implements :ZellersCongruence;
	:implementationLanguage "C";
	:implementationURL <http://www.lysator.liu.se/faq/c-faq/c-17.html#17-28>.

:ZhuTakaoka			a :Algorithm;
	rdfs:comment "A string matching algorithm that is a variant of the Boyer-Moore algorithm.  It uses two consecutive text characters to compute the bad character shift.  It is faster when the alphabet or pattern is small, but the skip table grows quickly, slowing the pre-processing phase.";
	rdfs:subClassOf :StringMatching;
	rdfs:label "Zhu-Takaoka".

:ZhuTakaokaImplementation1 a :Program;
	:implements :ZhuTakaoka;
	:implementationLanguage "C";
	:implementationURL <http://www-igm.univ-mlv.fr/~lecroq/string/node20.html>.

:Zipper				a :DataStructure;
	rdfs:comment "A data structure equivalent to a binary tree that is \"opened\" so that some node is accessible.  It consists of a pair: the current node, along with information to reconstruct the tree.  Reconstruction information is called the path or context.  A move-to-left-child operation returns the left subtree, along with a new path, which has (i) a Left value, (ii) the current node, (iii) the right subtree, and (iv) any previous path.  A similar operation moves to the right child.  A move-up operation returns a tree rebuilt from the path information and the current node, along with the previous path.";
	rdfs:label "zipper".

